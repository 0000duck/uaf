<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyuaf.client &mdash; PyUAF 2.3.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyUAF 2.3.0 documentation" href="index.html" />
    <link rel="next" title="pyuaf.client.connectionsteps" href="api_pyuaf_client_connectionsteps.html" />
    <link rel="prev" title="pyuaf" href="api_pyuaf.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api_pyuaf_client_connectionsteps.html" title="pyuaf.client.connectionsteps"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="api_pyuaf.html" title="pyuaf"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyUAF 2.3.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-pyuaf.client">
<span id="pyuaf-client"></span><h1><code class="docutils literal"><span class="pre">pyuaf.client</span></code><a class="headerlink" href="#module-pyuaf.client" title="Permalink to this headline">¶</a></h1>
<p><strong>SUMMARY of submodules:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="api_pyuaf_client_connectionsteps.html#module-pyuaf.client.connectionsteps" title="pyuaf.client.connectionsteps"><code class="xref py py-obj docutils literal"><span class="pre">connectionsteps</span></code></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="api_pyuaf_client_monitoreditemstates.html#module-pyuaf.client.monitoreditemstates" title="pyuaf.client.monitoreditemstates"><code class="xref py py-obj docutils literal"><span class="pre">monitoreditemstates</span></code></a></td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="api_pyuaf_client_requests.html#module-pyuaf.client.requests" title="pyuaf.client.requests"><code class="xref py py-obj docutils literal"><span class="pre">requests</span></code></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="api_pyuaf_client_results.html#module-pyuaf.client.results" title="pyuaf.client.results"><code class="xref py py-obj docutils literal"><span class="pre">results</span></code></a></td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="api_pyuaf_client_sessionstates.html#module-pyuaf.client.sessionstates" title="pyuaf.client.sessionstates"><code class="xref py py-obj docutils literal"><span class="pre">sessionstates</span></code></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="api_pyuaf_client_settings.html#module-pyuaf.client.settings" title="pyuaf.client.settings"><code class="xref py py-obj docutils literal"><span class="pre">settings</span></code></a></td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="api_pyuaf_client_subscriptionstates.html#module-pyuaf.client.subscriptionstates" title="pyuaf.client.subscriptionstates"><code class="xref py py-obj docutils literal"><span class="pre">subscriptionstates</span></code></a></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>SUMMARY of classes:</strong></p>
<blockquote>
<div>See sidebar.</div></blockquote>
<div class="section" id="class-client">
<h2><em>class</em> Client<a class="headerlink" href="#class-client" title="Permalink to this headline">¶</a></h2>
<p><strong>SUMMARY</strong>:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>Constructor:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client" title="pyuaf.client.Client"><code class="xref py py-obj docutils literal"><span class="pre">Client</span></code></a>([settings,&nbsp;loggingCallback])</td>
<td>Construct a UAF client.</td>
</tr>
</tbody>
</table>
</dd>
<dt><em>Client settings:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.clientSettings" title="pyuaf.client.Client.clientSettings"><code class="xref py py-obj docutils literal"><span class="pre">Client.clientSettings</span></code></a>()</td>
<td>Get a copy of the current client settings.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.setClientSettings" title="pyuaf.client.Client.setClientSettings"><code class="xref py py-obj docutils literal"><span class="pre">Client.setClientSettings</span></code></a>(settings)</td>
<td>Change the client settings.</td>
</tr>
</tbody>
</table>
</dd>
<dt><em>Synchronous service calls:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.browse" title="pyuaf.client.Client.browse"><code class="xref py py-obj docutils literal"><span class="pre">Client.browse</span></code></a>(addresses[,&nbsp;maxAutoBrowseNext])</td>
<td>Browse a number of nodes synchronously.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.browseNext" title="pyuaf.client.Client.browseNext"><code class="xref py py-obj docutils literal"><span class="pre">Client.browseNext</span></code></a>(addresses,&nbsp;...)</td>
<td>Continue a previous synchronous Browse request, in case you didn&#8217;t use the automatic BrowseNext feature of the UAF.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.call" title="pyuaf.client.Client.call"><code class="xref py py-obj docutils literal"><span class="pre">Client.call</span></code></a>(objectAddress,&nbsp;methodAddress[,&nbsp;...])</td>
<td>Invoke a remote method call.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.createMonitoredData" title="pyuaf.client.Client.createMonitoredData"><code class="xref py py-obj docutils literal"><span class="pre">Client.createMonitoredData</span></code></a>(addresses[,&nbsp;...])</td>
<td>Create one or more monitored data items.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.createMonitoredEvents" title="pyuaf.client.Client.createMonitoredEvents"><code class="xref py py-obj docutils literal"><span class="pre">Client.createMonitoredEvents</span></code></a>(addresses[,&nbsp;...])</td>
<td>Create one or more monitored event items.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.historyReadModified" title="pyuaf.client.Client.historyReadModified"><code class="xref py py-obj docutils literal"><span class="pre">Client.historyReadModified</span></code></a>(addresses,&nbsp;...[,&nbsp;...])</td>
<td>Read the modification information of the historical data from one or more nodes synchronously.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.historyReadRaw" title="pyuaf.client.Client.historyReadRaw"><code class="xref py py-obj docutils literal"><span class="pre">Client.historyReadRaw</span></code></a>(addresses,&nbsp;startTime,&nbsp;...)</td>
<td>Read the raw historical data from one or more nodes synchronously.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.read" title="pyuaf.client.Client.read"><code class="xref py py-obj docutils literal"><span class="pre">Client.read</span></code></a>(addresses[,&nbsp;attributeId])</td>
<td>Read a number of node attributes synchronously.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.setMonitoringMode" title="pyuaf.client.Client.setMonitoringMode"><code class="xref py py-obj docutils literal"><span class="pre">Client.setMonitoringMode</span></code></a>(clientHandles,&nbsp;...)</td>
<td>Set the monitoring mode for the specified monitored items.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.setPublishingMode" title="pyuaf.client.Client.setPublishingMode"><code class="xref py py-obj docutils literal"><span class="pre">Client.setPublishingMode</span></code></a>(...[,&nbsp;serviceSettings])</td>
<td>Set the publishing mode, by specifying a subscription handle.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.write" title="pyuaf.client.Client.write"><code class="xref py py-obj docutils literal"><span class="pre">Client.write</span></code></a>(addresses,&nbsp;data[,&nbsp;attributeId])</td>
<td>Write a number of node attributes synchronously.</td>
</tr>
</tbody>
</table>
</dd>
<dt><em>Asynchronous service calls:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.beginCall" title="pyuaf.client.Client.beginCall"><code class="xref py py-obj docutils literal"><span class="pre">Client.beginCall</span></code></a>(objectAddress,&nbsp;methodAddress)</td>
<td>Invoke a remote method call asynchronously.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.beginRead" title="pyuaf.client.Client.beginRead"><code class="xref py py-obj docutils literal"><span class="pre">Client.beginRead</span></code></a>(addresses[,&nbsp;attributeId,&nbsp;...])</td>
<td>Read a number of node attributes asynchronously.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.beginWrite" title="pyuaf.client.Client.beginWrite"><code class="xref py py-obj docutils literal"><span class="pre">Client.beginWrite</span></code></a>(addresses,&nbsp;data[,&nbsp;...])</td>
<td>Write a number of node attributes asynchronously.</td>
</tr>
</tbody>
</table>
</dd>
<dt><em>Callback functions for asynchronous service calls:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.callComplete" title="pyuaf.client.Client.callComplete"><code class="xref py py-obj docutils literal"><span class="pre">Client.callComplete</span></code></a>(result)</td>
<td>Override this method to catch the result of asynchronous method call requests.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.readComplete" title="pyuaf.client.Client.readComplete"><code class="xref py py-obj docutils literal"><span class="pre">Client.readComplete</span></code></a>(result)</td>
<td>Override this method to catch the result of asynchronous read requests.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.writeComplete" title="pyuaf.client.Client.writeComplete"><code class="xref py py-obj docutils literal"><span class="pre">Client.writeComplete</span></code></a>(result)</td>
<td>Override this method to catch the result of asynchronous write requests.</td>
</tr>
</tbody>
</table>
</dd>
<dt><em>Callback functions for sessions, subscriptions and monitored items:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.dataChangesReceived" title="pyuaf.client.Client.dataChangesReceived"><code class="xref py py-obj docutils literal"><span class="pre">Client.dataChangesReceived</span></code></a>(dataNotifications)</td>
<td>Override this method to catch the &#8220;data change&#8221; notifications of MonitoredItems.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.eventsReceived" title="pyuaf.client.Client.eventsReceived"><code class="xref py py-obj docutils literal"><span class="pre">Client.eventsReceived</span></code></a>(eventNotifications)</td>
<td>Override this method to catch the &#8220;event&#8221; notifications of MonitoredItems.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.connectionStatusChanged" title="pyuaf.client.Client.connectionStatusChanged"><code class="xref py py-obj docutils literal"><span class="pre">Client.connectionStatusChanged</span></code></a>(info)</td>
<td>Override this method to receive connection status changes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.subscriptionStatusChanged" title="pyuaf.client.Client.subscriptionStatusChanged"><code class="xref py py-obj docutils literal"><span class="pre">Client.subscriptionStatusChanged</span></code></a>(info)</td>
<td>Override this method to receive subscription status changes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.keepAliveReceived" title="pyuaf.client.Client.keepAliveReceived"><code class="xref py py-obj docutils literal"><span class="pre">Client.keepAliveReceived</span></code></a>(notification)</td>
<td>You should override this method if you want to process keep alive messages from the UAF.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.notificationsMissing" title="pyuaf.client.Client.notificationsMissing"><code class="xref py py-obj docutils literal"><span class="pre">Client.notificationsMissing</span></code></a>(info,&nbsp;...)</td>
<td>Override this method to handle missing notifications.</td>
</tr>
</tbody>
</table>
</dd>
<dt><em>Register your own callback functions for sessions, subscriptions and monitored items:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.registerConnectionStatusCallback" title="pyuaf.client.Client.registerConnectionStatusCallback"><code class="xref py py-obj docutils literal"><span class="pre">Client.registerConnectionStatusCallback</span></code></a>(callback)</td>
<td>Register a callback to receive connection status changes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.registerSubscriptionStatusCallback" title="pyuaf.client.Client.registerSubscriptionStatusCallback"><code class="xref py py-obj docutils literal"><span class="pre">Client.registerSubscriptionStatusCallback</span></code></a>(...)</td>
<td>Register a callback to receive connection status changes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.registerKeepAliveCallback" title="pyuaf.client.Client.registerKeepAliveCallback"><code class="xref py py-obj docutils literal"><span class="pre">Client.registerKeepAliveCallback</span></code></a>(callback[,&nbsp;...])</td>
<td>Register a callback to handle KeepAlive notifications.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.registerNotificationsMissingCallback" title="pyuaf.client.Client.registerNotificationsMissingCallback"><code class="xref py py-obj docutils literal"><span class="pre">Client.registerNotificationsMissingCallback</span></code></a>(...)</td>
<td>Register a callback to handle missing notifications.</td>
</tr>
</tbody>
</table>
</dd>
<dt><em>Information about the current sessions, subscriptions and monitored items:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.allSessionInformations" title="pyuaf.client.Client.allSessionInformations"><code class="xref py py-obj docutils literal"><span class="pre">Client.allSessionInformations</span></code></a>()</td>
<td>Get information about all sessions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.allSubscriptionInformations" title="pyuaf.client.Client.allSubscriptionInformations"><code class="xref py py-obj docutils literal"><span class="pre">Client.allSubscriptionInformations</span></code></a>()</td>
<td>Get information about all subscriptions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.monitoredItemInformation" title="pyuaf.client.Client.monitoredItemInformation"><code class="xref py py-obj docutils literal"><span class="pre">Client.monitoredItemInformation</span></code></a>(clientHandle)</td>
<td>Get information about the specified monitored item.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.sessionInformation" title="pyuaf.client.Client.sessionInformation"><code class="xref py py-obj docutils literal"><span class="pre">Client.sessionInformation</span></code></a>(clientConnectionId)</td>
<td>Get information about the specified session.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.subscriptionInformation" title="pyuaf.client.Client.subscriptionInformation"><code class="xref py py-obj docutils literal"><span class="pre">Client.subscriptionInformation</span></code></a>(...)</td>
<td>Get information about the specified subscription.</td>
</tr>
</tbody>
</table>
</dd>
<dt><em>Fully configurable generic service calls:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-obj docutils literal"><span class="pre">Client.processRequest</span></code></a>(request[,&nbsp;...])</td>
<td>Process a generic request (as found in <a class="reference internal" href="api_pyuaf_client_requests.html#module-pyuaf.client.requests" title="pyuaf.client.requests"><code class="xref py py-mod docutils literal"><span class="pre">pyuaf.client.requests</span></code></a>).</td>
</tr>
</tbody>
</table>
</dd>
<dt><em>Manually created sessions and subscriptions:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.manuallyConnect" title="pyuaf.client.Client.manuallyConnect"><code class="xref py py-obj docutils literal"><span class="pre">Client.manuallyConnect</span></code></a>(serverUri[,&nbsp;...])</td>
<td>Create a session manually (instead of having the UAF do it behind the scenes).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.manuallyConnectToEndpoint" title="pyuaf.client.Client.manuallyConnectToEndpoint"><code class="xref py py-obj docutils literal"><span class="pre">Client.manuallyConnectToEndpoint</span></code></a>(endpointUrl)</td>
<td>Manually connect to a specific endpoint, without using the discovery services.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.manuallyDisconnect" title="pyuaf.client.Client.manuallyDisconnect"><code class="xref py py-obj docutils literal"><span class="pre">Client.manuallyDisconnect</span></code></a>(clientConnectionId)</td>
<td>Disconnect the session manually.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.manuallySubscribe" title="pyuaf.client.Client.manuallySubscribe"><code class="xref py py-obj docutils literal"><span class="pre">Client.manuallySubscribe</span></code></a>(clientConnectionId)</td>
<td>Create a subscription manually.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.manuallyUnsubscribe" title="pyuaf.client.Client.manuallyUnsubscribe"><code class="xref py py-obj docutils literal"><span class="pre">Client.manuallyUnsubscribe</span></code></a>(...)</td>
<td>Delete the subscription manually.</td>
</tr>
</tbody>
</table>
</dd>
<dt><em>Handle untrusted server certificates:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.untrustedServerCertificateReceived" title="pyuaf.client.Client.untrustedServerCertificateReceived"><code class="xref py py-obj docutils literal"><span class="pre">Client.untrustedServerCertificateReceived</span></code></a>(...)</td>
<td>Override this method if you want to handle an untrusted certificate.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.registerUntrustedServerCertificateCallback" title="pyuaf.client.Client.registerUntrustedServerCertificateCallback"><code class="xref py py-obj docutils literal"><span class="pre">Client.registerUntrustedServerCertificateCallback</span></code></a>(...)</td>
<td>Register a callback function to handle untrusted certificates during the connection process.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.unregisterUntrustedServerCertificateCallback" title="pyuaf.client.Client.unregisterUntrustedServerCertificateCallback"><code class="xref py py-obj docutils literal"><span class="pre">Client.unregisterUntrustedServerCertificateCallback</span></code></a>()</td>
<td>Unregister a callback function to stop handling untrusted certificates.</td>
</tr>
</tbody>
</table>
</dd>
<dt><em>Catch the logging of the UAF:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.logMessageReceived" title="pyuaf.client.Client.logMessageReceived"><code class="xref py py-obj docutils literal"><span class="pre">Client.logMessageReceived</span></code></a>(message)</td>
<td>Override this method if you want to process logging output from the UAF.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.registerLoggingCallback" title="pyuaf.client.Client.registerLoggingCallback"><code class="xref py py-obj docutils literal"><span class="pre">Client.registerLoggingCallback</span></code></a>(callback)</td>
<td>Register a callback function to receive all log messages.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.unregisterLoggingCallback" title="pyuaf.client.Client.unregisterLoggingCallback"><code class="xref py py-obj docutils literal"><span class="pre">Client.unregisterLoggingCallback</span></code></a>()</td>
<td>Unregister a callback function to stop receiving all log messages.</td>
</tr>
</tbody>
</table>
</dd>
<dt><em>Discovery:</em></dt>
<dd><table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyuaf.client.Client.serversFound" title="pyuaf.client.Client.serversFound"><code class="xref py py-obj docutils literal"><span class="pre">Client.serversFound</span></code></a>()</td>
<td>Get a list of the application descriptions of the servers found in the discovery process.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyuaf.client.Client.findServersNow" title="pyuaf.client.Client.findServersNow"><code class="xref py py-obj docutils literal"><span class="pre">Client.findServersNow</span></code></a>()</td>
<td>Discover the servers immediately (instead of waiting for the background thread) by  using the OPC UA FindServers service.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div></blockquote>
<p><strong>DETAILED DESCRIPTION:</strong>:</p>
<dl class="class">
<dt id="pyuaf.client.Client">
<em class="property">class </em><code class="descclassname">pyuaf.client.</code><code class="descname">Client</code><span class="sig-paren">(</span><em>settings=None</em>, <em>loggingCallback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a UAF client.</p>
<p>Usage example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># examples/pyuaf/client/how_to_create_a_client.py</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">EXAMPLE: how to create a client</span>
<span class="sd">====================================================================================================</span>

<span class="sd">The Client constructor signature looks like this: </span>

<span class="sd">  pyuaf.client.Client.__init__(settings=None, loggingCallback=None)</span>

<span class="sd">with:</span>
<span class="sd">  - &#39;settings&#39;: optional: could be </span>
<span class="sd">      - a pyuaf.client.settings.ClientSettings instance</span>
<span class="sd">      - or simply a string (the name of the client)</span>
<span class="sd">      - or None (so default pyuaf.client.settings.ClientSettings() are used).</span>
<span class="sd">  - &#39;loggingCallback&#39;: optional: a callback function to catch log messages of type pyuaf.util.LogMessage.</span>

<span class="sd">See the PyUAF HTML documentation for more info.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">pyuaf</span>
<span class="kn">from</span> <span class="nn">pyuaf.client</span>          <span class="k">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">pyuaf.client.settings</span> <span class="k">import</span> <span class="n">ClientSettings</span>
<span class="kn">from</span> <span class="nn">pyuaf.util</span>            <span class="k">import</span> <span class="n">loglevels</span><span class="p">,</span> <span class="n">Address</span><span class="p">,</span> <span class="n">NodeId</span>

<span class="c1"># we can create some ClientSettings:</span>
<span class="n">settings</span> <span class="o">=</span> <span class="n">ClientSettings</span><span class="p">()</span>
<span class="n">settings</span><span class="o">.</span><span class="n">applicationName</span> <span class="o">=</span> <span class="s2">&quot;MyClient&quot;</span>
<span class="n">settings</span><span class="o">.</span><span class="n">discoveryUrls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;opc.tcp://localhost:4841&quot;</span><span class="p">)</span>
<span class="n">settings</span><span class="o">.</span><span class="n">logToStdOutLevel</span>   <span class="o">=</span> <span class="n">loglevels</span><span class="o">.</span><span class="n">Info</span>   <span class="c1"># print Info, Warning and Error logging to the console </span>
<span class="n">settings</span><span class="o">.</span><span class="n">logToCallbackLevel</span> <span class="o">=</span> <span class="n">loglevels</span><span class="o">.</span><span class="n">Debug</span>  <span class="c1"># send Debug, Info, Warning and Error logging to the callback</span>

<span class="c1"># And if you want to catch the logging output, you may also define a callback.</span>
<span class="c1"># In this case we define a callback to write the logging output to a file in the user&#39;s home directory.</span>
<span class="c1"># (but this callback is optional of course, only define one if you want to do something more with the</span>
<span class="c1">#  logging output than simply printing it to the console (i.e. sending it to the stdout))</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~/my_logging_output.txt&quot;</span><span class="p">),</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="n">logDetailsString</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">logDetailsString</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%a, </span><span class="si">%d</span><span class="s2"> %b %Y %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">ctime</span><span class="p">))</span>
    <span class="n">logDetailsString</span> <span class="o">+=</span> <span class="s2">&quot;.</span><span class="si">%.3d</span><span class="s2"> &quot;</span> <span class="o">%</span><span class="n">msg</span><span class="o">.</span><span class="n">msec</span>
    <span class="n">logDetailsString</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%-10s</span><span class="s2"> &quot;</span> <span class="o">%</span><span class="n">msg</span><span class="o">.</span><span class="n">applicationName</span>
    <span class="n">logDetailsString</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%-20s</span><span class="s2"> &quot;</span> <span class="o">%</span><span class="n">msg</span><span class="o">.</span><span class="n">loggerName</span>
    <span class="n">logDetailsString</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%-8s</span><span class="s2"> &quot;</span>  <span class="o">%</span><span class="n">loglevels</span><span class="o">.</span><span class="n">toString</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">level</span><span class="p">)</span>
    <span class="c1"># msg.message may contain multiple lines, so we prepend the other logging details in</span>
    <span class="c1"># front of each line:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">logDetailsString</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>


<span class="c1"># Example 0: create a client with the default settings and no logging callback</span>
<span class="c1"># --------------------------------------------------------------------------------------------------</span>
<span class="n">client0</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>

<span class="c1"># Example 1: create a client by specifying the settings</span>
<span class="c1"># --------------------------------------------------------------------------------------------------</span>
<span class="n">client1</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>

<span class="c1"># Example 2: create a client by specifying the settings</span>
<span class="c1"># --------------------------------------------------------------------------------------------------</span>
<span class="n">client2</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

<span class="c1"># Example 3: create a client by specifying only the logging callback</span>
<span class="c1"># --------------------------------------------------------------------------------------------------</span>
<span class="n">client3</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">loggingCallback</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>

<span class="c1"># you can still provide settings and register a logging callback afterwards, but you&#39;ll need to use:</span>
<span class="c1">#  client0.setClientSettings(settings)</span>
<span class="c1">#  client0.registerLoggingCallback(callback)</span>


<span class="c1"># read the Value attribute of some non-existing node in order to have some Error output sent to the callback:</span>
<span class="n">client2</span><span class="o">.</span><span class="n">read</span><span class="p">([</span><span class="n">Address</span><span class="p">(</span><span class="n">NodeId</span><span class="p">(</span><span class="s2">&quot;InvalidIdentifier&quot;</span><span class="p">,</span><span class="s2">&quot;InvalidNamespace&quot;</span><span class="p">),</span><span class="s2">&quot;InvalidServerURI&quot;</span><span class="p">)])</span>

<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>settings</strong> (<a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ClientSettings" title="pyuaf.client.settings.ClientSettings"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.settings.ClientSettings</span></code></a> or <code class="docutils literal"><span class="pre">str</span></code> or None) &#8211; <p>Can be:</p>
<ul>
<li>the settings of the client (of type <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ClientSettings" title="pyuaf.client.settings.ClientSettings"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.settings.ClientSettings</span></code></a>)</li>
<li>or simply the name of the client application (as a <code class="docutils literal"><span class="pre">str</span></code>)</li>
<li>or None for defaults.</li>
</ul>
</li>
<li><strong>callback</strong> &#8211; A callback function for the logging. This function should have one 
input argument, which you should call &#8220;msg&#8221; or so,
because this argument is of type <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.LogMessage" title="pyuaf.util.LogMessage"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.util.LogMessage</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyuaf.client.Client.allSessionInformations">
<code class="descname">allSessionInformations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.allSessionInformations" title="Permalink to this definition">¶</a></dt>
<dd><p>Get information about all sessions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of information objects about all sessions.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="#pyuaf.client.SessionInformation" title="pyuaf.client.SessionInformation"><code class="xref py py-class docutils literal"><span class="pre">SessionInformation</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.allSubscriptionInformations">
<code class="descname">allSubscriptionInformations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.allSubscriptionInformations" title="Permalink to this definition">¶</a></dt>
<dd><p>Get information about all subscriptions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of information objects about all subscriptions.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="#pyuaf.client.SubscriptionInformation" title="pyuaf.client.SubscriptionInformation"><code class="xref py py-class docutils literal"><span class="pre">SubscriptionInformation</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.beginCall">
<code class="descname">beginCall</code><span class="sig-paren">(</span><em>objectAddress</em>, <em>methodAddress</em>, <em>inputArgs=[]</em>, <em>callback=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.beginCall" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke a remote method call asynchronously.</p>
<dl class="docutils">
<dt>Unlike &#8220;strict object-oriented&#8221; method calling, a method is called by specifying both </dt>
<dd><ul class="first last simple">
<li>the method itself (parameter methodAddress)</li>
<li>the object in which context the method should be invoked (parameter objectAddress).</li>
</ul>
</dd>
</dl>
<p>In other words, in OPC UA you can call a method on different objects. In contrast to strict
object-oriented languages, where a method can only be called on the object that &#8220;owns&#8221; the
method.</p>
<p>This is a convenience function for calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-class docutils literal"><span class="pre">processRequest</span></code></a> with 
a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.MethodCallRequest" title="pyuaf.client.requests.MethodCallRequest"><code class="xref py py-class docutils literal"><span class="pre">MethodCallRequest</span></code></a> as its first argument.
For full flexibility, use that function. For instance, if you want to call multiple 
methods at once, you can do so by creating a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.MethodCallRequest" title="pyuaf.client.requests.MethodCallRequest"><code class="xref py py-class docutils literal"><span class="pre">MethodCallRequest</span></code></a> 
and adding multiple targets.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The callbacks will run in a separate thread, and therefore any exception they 
raise will <em>not</em> be handled or propagated. So your callbacks should have a try-except 
clause if you want to be able to properly handle the exceptions that they may raise.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>objectAddress</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; The address of the object node on which to call the method.</li>
<li><strong>methodAddress</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; The address of the method node to call.</li>
<li><strong>inputArgs</strong> (<code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="api_pyuaf_util_primitives.html#pyuaf.util.primitives.UInt32" title="pyuaf.util.primitives.UInt32"><code class="xref py py-class docutils literal"><span class="pre">UInt32</span></code></a>,
or <code class="docutils literal"><span class="pre">list</span></code> of any other supported data type.) &#8211; A list of input arguments.</li>
<li><strong>callback</strong> &#8211; A callback function to receive the result. This function should have one
argument (which will be of type <a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.MethodCallResult" title="pyuaf.client.results.MethodCallResult"><code class="xref py py-class docutils literal"><span class="pre">MethodCallResult</span></code></a>).</li>
<li><strong>kwargs</strong> &#8211; <p>The following **kwargs are available (see <a class="reference internal" href="api_client_kwargs.html#note-client-kwargs"><span class="std std-ref">A note on **kwargs for Client services</span></a>):</p>
<ul>
<li>clientConnectionId: (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>sessionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>)</li>
<li>serviceSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.MethodCallSettings" title="pyuaf.client.settings.MethodCallSettings"><code class="xref py py-class docutils literal"><span class="pre">MethodCallSettings</span></code></a>)</li>
<li>translateSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings" title="pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings"><code class="xref py py-class docutils literal"><span class="pre">TranslateBrowsePathsToNodeIdsSettings</span></code></a>)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result of the asynchronous method call request.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.AsyncMethodCallResult" title="pyuaf.client.results.AsyncMethodCallResult"><code class="xref py py-class docutils literal"><span class="pre">AsyncMethodCallResult</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.beginRead">
<code class="descname">beginRead</code><span class="sig-paren">(</span><em>addresses</em>, <em>attributeId=13</em>, <em>callback=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.beginRead" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a number of node attributes asynchronously.</p>
<p>This is a convenience function for calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-class docutils literal"><span class="pre">processRequest</span></code></a> with 
a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.ReadRequest" title="pyuaf.client.requests.ReadRequest"><code class="xref py py-class docutils literal"><span class="pre">ReadRequest</span></code></a> as its first argument.
For full flexibility, use that function.</p>
<dl class="docutils">
<dt>Asynchronous communication can be handled in two ways:</dt>
<dd><ul class="first last simple">
<li>you specify a callback function (a function with one argument). This function 
will be called by the UAF when the asynchronous result is received. The argument of this
function call will be of type <a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.ReadResult" title="pyuaf.client.results.ReadResult"><code class="xref py py-class docutils literal"><span class="pre">ReadResult</span></code></a>.</li>
<li>you leave the &#8216;callback&#8217; argument None. In this case, your client application need to 
inherit from the <a class="reference internal" href="#pyuaf.client.Client" title="pyuaf.client.Client"><code class="xref py py-class docutils literal"><span class="pre">Client</span></code></a> class, so it can override the  
<a class="reference internal" href="#pyuaf.client.Client.readComplete" title="pyuaf.client.Client.readComplete"><code class="xref py py-meth docutils literal"><span class="pre">readComplete()</span></code></a> method.</li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Asynchronous requests MUST be invoked on a single session. Meaning:
the targets of asynchronous requests MUST belong to the same server (as the UAF can 
currently not reconstruct an asynchronous request that must be &#8220;split up&#8221; to be called
on multiple servers). If they don&#8217;t belong to the same server, an error will be raised.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The callbacks will run in a separate thread, and therefore any exception they 
raise will <em>not</em> be handled or propagated. So your callbacks should have a try-except 
clause if you want to be able to properly handle the exceptions that they may raise.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addresses</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; A single address or a list of addresses of nodes of which the specified 
attribute should be read.</li>
<li><strong>attributeId</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The id of the attribute to be read (e.g. <a class="reference internal" href="api_pyuaf_util_attributeids.html#pyuaf.util.attributeids.Value" title="pyuaf.util.attributeids.Value"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.attributeids.Value</span></code></a>
or <a class="reference internal" href="api_pyuaf_util_attributeids.html#pyuaf.util.attributeids.DisplayName" title="pyuaf.util.attributeids.DisplayName"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.attributeids.DisplayName</span></code></a>).</li>
<li><strong>callback</strong> &#8211; A callback function to receive the asynchronous result. This function 
should have one argument (which will be of type <a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.ReadResult" title="pyuaf.client.results.ReadResult"><code class="xref py py-class docutils literal"><span class="pre">ReadResult</span></code></a>).</li>
<li><strong>kwargs</strong> &#8211; <p>The following **kwargs are available (see <a class="reference internal" href="api_client_kwargs.html#note-client-kwargs"><span class="std std-ref">A note on **kwargs for Client services</span></a>):</p>
<ul>
<li>clientConnectionId: (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>sessionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>)</li>
<li>serviceSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ReadSettings" title="pyuaf.client.settings.ReadSettings"><code class="xref py py-class docutils literal"><span class="pre">ReadSettings</span></code></a>)</li>
<li>translateSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings" title="pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings"><code class="xref py py-class docutils literal"><span class="pre">TranslateBrowsePathsToNodeIdsSettings</span></code></a>)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The &#8220;immediate&#8221; result of the asynchronous read request.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.AsyncReadResult" title="pyuaf.client.results.AsyncReadResult"><code class="xref py py-class docutils literal"><span class="pre">AsyncReadResult</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.beginWrite">
<code class="descname">beginWrite</code><span class="sig-paren">(</span><em>addresses</em>, <em>data</em>, <em>attributeId=13</em>, <em>callback=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.beginWrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a number of node attributes asynchronously.</p>
<p>This is a convenience function for calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-class docutils literal"><span class="pre">processRequest</span></code></a> with 
a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.AsyncWriteRequest" title="pyuaf.client.requests.AsyncWriteRequest"><code class="xref py py-class docutils literal"><span class="pre">AsyncWriteRequest</span></code></a> as its first argument.
For full flexibility, use that function.</p>
<dl class="docutils">
<dt>Asynchronous communication can be handled in two ways:</dt>
<dd><ul class="first last simple">
<li>you specify a callback function (a function with one argument). This function 
will be called by the UAF when the asynchronous result is received. The argument of this
function call will be of type <a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.WriteResult" title="pyuaf.client.results.WriteResult"><code class="xref py py-class docutils literal"><span class="pre">WriteResult</span></code></a>.</li>
<li>you leave the &#8216;callback&#8217; argument None. In this case, your client application need to 
inherit from the <a class="reference internal" href="#pyuaf.client.Client" title="pyuaf.client.Client"><code class="xref py py-class docutils literal"><span class="pre">Client</span></code></a> class, so it can override the  
<a class="reference internal" href="#pyuaf.client.Client.writeComplete" title="pyuaf.client.Client.writeComplete"><code class="xref py py-meth docutils literal"><span class="pre">writeComplete()</span></code></a> method.</li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Asynchronous requests MUST be invoked on a single session. Meaning:
the targets of asynchronous requests MUST belong to the same server (as the UAF can 
currently not reconstruct an asynchronous request that must be &#8220;split up&#8221; to be called
on multiple servers). If they don&#8217;t belong to the same server, an error will be raised.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The callbacks will run in a separate thread, and therefore any exception they 
raise will <em>not</em> be handled or propagated. So your callbacks should have a try-except 
clause if you want to be able to properly handle the exceptions that they may raise.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addresses</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; A single address or a list of addresses of nodes of which the specified 
attribute should be written.</li>
<li><strong>data</strong> (<a class="reference internal" href="api_pyuaf_util_primitives.html#pyuaf.util.primitives.UInt32" title="pyuaf.util.primitives.UInt32"><code class="xref py py-class docutils literal"><span class="pre">UInt32</span></code></a> or <code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="api_pyuaf_util_primitives.html#pyuaf.util.primitives.UInt32" title="pyuaf.util.primitives.UInt32"><code class="xref py py-class docutils literal"><span class="pre">UInt32</span></code></a>
or any other data type of the supported dynamic data types (or a <code class="docutils literal"><span class="pre">list</span></code> of them).) &#8211; A single value or a list of values to be written.</li>
<li><strong>attributeId</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The id of the attribute to be written (e.g. <a class="reference internal" href="api_pyuaf_util_attributeids.html#pyuaf.util.attributeids.Value" title="pyuaf.util.attributeids.Value"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.attributeids.Value</span></code></a>
or <a class="reference internal" href="api_pyuaf_util_attributeids.html#pyuaf.util.attributeids.DisplayName" title="pyuaf.util.attributeids.DisplayName"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.attributeids.DisplayName</span></code></a>) for all addresses.</li>
<li><strong>callback</strong> &#8211; A callback function to receive the asynchronous result. This function 
should have one argument (which will be of type <a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.WriteResult" title="pyuaf.client.results.WriteResult"><code class="xref py py-class docutils literal"><span class="pre">WriteResult</span></code></a>).</li>
<li><strong>kwargs</strong> &#8211; <p>The following **kwargs are available (see <a class="reference internal" href="api_client_kwargs.html#note-client-kwargs"><span class="std std-ref">A note on **kwargs for Client services</span></a>):</p>
<ul>
<li>clientConnectionId: (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>sessionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>)</li>
<li>serviceSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.WriteSettings" title="pyuaf.client.settings.WriteSettings"><code class="xref py py-class docutils literal"><span class="pre">WriteSettings</span></code></a>)</li>
<li>translateSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings" title="pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings"><code class="xref py py-class docutils literal"><span class="pre">TranslateBrowsePathsToNodeIdsSettings</span></code></a>)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The &#8220;immediate&#8221; result of the asynchronous write request.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.AsyncWriteResult" title="pyuaf.client.results.AsyncWriteResult"><code class="xref py py-class docutils literal"><span class="pre">AsyncWriteResult</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.browse">
<code class="descname">browse</code><span class="sig-paren">(</span><em>addresses</em>, <em>maxAutoBrowseNext=100</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.browse" title="Permalink to this definition">¶</a></dt>
<dd><p>Browse a number of nodes synchronously.</p>
<p>This is a convenience method for calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-class docutils literal"><span class="pre">processRequest</span></code></a> with 
a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.BrowseRequest" title="pyuaf.client.requests.BrowseRequest"><code class="xref py py-class docutils literal"><span class="pre">BrowseRequest</span></code></a> as its first argument.
A BrowseRequest has many parameters (only few of them can be configured by this convenience
method), so for full flexibility use the other method.</p>
<p>The second parameter (maxAutoBrowseNext) allows you to use some handy extra functionality
of the UAF: the UAF can automatically invoke the BrowseNext service for you, if all browse
results couldn&#8217;t be fetched by the initial Browse service. This parameter specifies how
many times the UAF may silently invoke the BrowseNext service for you. Put it to 0 if you
want the &#8220;normal SDK behavior&#8221;, i.e. if you want to invoke the BrowseNext service manually.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addresses</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> of 
<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; A single address or a list of addresses of nodes that serve as 
the starting point to browse.</li>
<li><strong>maxAutoBrowseNext</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; How many times do you allow the UAF to automatically invoke a
BrowseNext for you (if that&#8217;s needed to fetch all results)? 
This parameter will always be used instead of the 
maxAutoBrowseNext attribute of the serviceSettings!</li>
<li><strong>kwargs</strong> &#8211; <p>The following **kwargs are available (see <a class="reference internal" href="api_client_kwargs.html#note-client-kwargs"><span class="std std-ref">A note on **kwargs for Client services</span></a>):</p>
<ul>
<li>clientConnectionId: (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>sessionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>)</li>
<li>serviceSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.BrowseSettings" title="pyuaf.client.settings.BrowseSettings"><code class="xref py py-class docutils literal"><span class="pre">BrowseSettings</span></code></a>)</li>
<li>translateSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings" title="pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings"><code class="xref py py-class docutils literal"><span class="pre">TranslateBrowsePathsToNodeIdsSettings</span></code></a>)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result of the browse request.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.BrowseResult" title="pyuaf.client.results.BrowseResult"><code class="xref py py-class docutils literal"><span class="pre">BrowseResult</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.browseNext">
<code class="descname">browseNext</code><span class="sig-paren">(</span><em>addresses</em>, <em>continuationPoints</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.browseNext" title="Permalink to this definition">¶</a></dt>
<dd><p>Continue a previous synchronous Browse request, in case you didn&#8217;t use the automatic
BrowseNext feature of the UAF.</p>
<p>You only need to use this function if you have put maxAutoBrowseNext to 0 in the previous
Browse request (or if the automatic BrowseNext calls still resulted in continuationPoints).
For your convenience, it&#8217;s much easier to simple use the browse() method, and let the
UAF do the BrowseNext calls for you!</p>
<p>This is a convenience method for calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-class docutils literal"><span class="pre">processRequest</span></code></a> with 
a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.BrowseNextRequest" title="pyuaf.client.requests.BrowseNextRequest"><code class="xref py py-class docutils literal"><span class="pre">BrowseNextRequest</span></code></a> as its first argument.
A BrowseNextRequest has many parameters (only few of them can be configured by this 
convenience method), so for full flexibility use the other method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addresses</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> 
of <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; A single address or a list of addresses of nodes that serve as 
the starting point to browse. You need to copy the addresses 
here from the original Browse request, so that the UAF can use 
these addresses to find out to which server the BrowseNext call 
should be sent.</li>
<li><strong>continuationPoints</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.ByteStringVector" title="pyuaf.util.ByteStringVector"><code class="xref py py-class docutils literal"><span class="pre">ByteStringVector</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> of 
Python <code class="docutils literal"><span class="pre">bytearray</span></code> objects.) &#8211; A <code class="docutils literal"><span class="pre">list</span></code> of continuation points (represented by the built-in 
Python <code class="docutils literal"><span class="pre">bytearray</span></code> objects).</li>
<li><strong>kwargs</strong> &#8211; <p>The following **kwargs are available (see <a class="reference internal" href="api_client_kwargs.html#note-client-kwargs"><span class="std std-ref">A note on **kwargs for Client services</span></a>):</p>
<ul>
<li>clientConnectionId: (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>sessionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>)</li>
<li>serviceSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.BrowseNextSettings" title="pyuaf.client.settings.BrowseNextSettings"><code class="xref py py-class docutils literal"><span class="pre">BrowseNextSettings</span></code></a>)</li>
<li>translateSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings" title="pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings"><code class="xref py py-class docutils literal"><span class="pre">TranslateBrowsePathsToNodeIdsSettings</span></code></a>)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result of the BrowseNext request.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.BrowseNextResult" title="pyuaf.client.results.BrowseNextResult"><code class="xref py py-class docutils literal"><span class="pre">BrowseNextResult</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.call">
<code class="descname">call</code><span class="sig-paren">(</span><em>objectAddress</em>, <em>methodAddress</em>, <em>inputArgs=[]</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.call" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke a remote method call.</p>
<dl class="docutils">
<dt>Unlike &#8220;strict object-oriented&#8221; method calling, a method is called by specifying both </dt>
<dd><ul class="first last simple">
<li>the method itself (parameter methodAddress)</li>
<li>the object in which context the method should be invoked (parameter objectAddress).</li>
</ul>
</dd>
</dl>
<p>In other words, in OPC UA you can call a method on different objects. In contrast to strict
object-oriented languages, where a method can only be called on the object that &#8220;owns&#8221; the
method.</p>
<p>This is a convenience function for calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-class docutils literal"><span class="pre">processRequest</span></code></a> with 
a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.MethodCallRequest" title="pyuaf.client.requests.MethodCallRequest"><code class="xref py py-class docutils literal"><span class="pre">MethodCallRequest</span></code></a> as its first argument.
For full flexibility, use that function. For instance, if you want to call multiple 
methods at once, you can do so by creating a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.MethodCallRequest" title="pyuaf.client.requests.MethodCallRequest"><code class="xref py py-class docutils literal"><span class="pre">MethodCallRequest</span></code></a> 
and adding multiple targets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>objectAddress</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; The address of the object node on which to call the method.</li>
<li><strong>methodAddress</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; The address of the method node to call.</li>
<li><strong>inputArgs</strong> (<code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="api_pyuaf_util_primitives.html#pyuaf.util.primitives.UInt32" title="pyuaf.util.primitives.UInt32"><code class="xref py py-class docutils literal"><span class="pre">UInt32</span></code></a>,
or <code class="docutils literal"><span class="pre">list</span></code> of any other supported data type.) &#8211; A list of input arguments.</li>
<li><strong>kwargs</strong> &#8211; <p>The following **kwargs are available (see <a class="reference internal" href="api_client_kwargs.html#note-client-kwargs"><span class="std std-ref">A note on **kwargs for Client services</span></a>):</p>
<ul>
<li>clientConnectionId: (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>sessionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>)</li>
<li>serviceSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.MethodCallSettings" title="pyuaf.client.settings.MethodCallSettings"><code class="xref py py-class docutils literal"><span class="pre">MethodCallSettings</span></code></a>)</li>
<li>translateSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings" title="pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings"><code class="xref py py-class docutils literal"><span class="pre">TranslateBrowsePathsToNodeIdsSettings</span></code></a>)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result of the method call request.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.MethodCallResult" title="pyuaf.client.results.MethodCallResult"><code class="xref py py-class docutils literal"><span class="pre">MethodCallResult</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.callComplete">
<code class="descname">callComplete</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.callComplete" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method to catch the result of asynchronous method call requests.</p>
<p>This method will only be called by the UAF if you didn&#8217;t provide an &#8220;external&#8221; callback
function already when you began the asynchronous method call request.</p>
<p>In other words, there are two ways how you can catch the result of asynchronous method calls:</p>
<blockquote>
<div><ul class="simple">
<li>either by calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-meth docutils literal"><span class="pre">processRequest()</span></code></a> <em>without</em> providing an external callback function
via the &#8216;resultCallback&#8217; argument &#8211;&gt; then you need to override <a class="reference internal" href="#pyuaf.client.Client.callComplete" title="pyuaf.client.Client.callComplete"><code class="xref py py-meth docutils literal"><span class="pre">callComplete()</span></code></a></li>
<li>or by calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-meth docutils literal"><span class="pre">processRequest()</span></code></a> <em>with</em> providing an external callback function
via the &#8216;resultCallback&#8217; argument &#8211;&gt; then only the external callback function will be called.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>result</strong> (<a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.MethodCallResult" title="pyuaf.client.results.MethodCallResult"><code class="xref py py-class docutils literal"><span class="pre">MethodCallResult</span></code></a>) &#8211; The asynchronously received method call result.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.clientSettings">
<code class="descname">clientSettings</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.clientSettings" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a copy of the current client settings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The currently active settings.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ClientSettings" title="pyuaf.client.settings.ClientSettings"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.settings.ClientSettings</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.connectErrorReceived">
<code class="descname">connectErrorReceived</code><span class="sig-paren">(</span><em>clientConnectionId</em>, <em>connectionStep</em>, <em>sdkStatus</em>, <em>clientSideError</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.connectErrorReceived" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method to handle connect errors by the SDK.</p>
<p>By default, this method returns False, which means that client errors by the SDK
will cause a failure of the connection.
Return True if the client SDK error should be ignored.
If the error was not a client-side SDK error (meaning: if clientSideError is False)
then the return value will be ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clientConnectionId</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The ID of the session that raised the connectError.</li>
<li><strong>connectionStep</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The failing connection step, as an <code class="docutils literal"><span class="pre">int</span></code> defined by <a class="reference internal" href="api_pyuaf_client_connectionsteps.html#module-pyuaf.client.connectionsteps" title="pyuaf.client.connectionsteps"><code class="xref py py-mod docutils literal"><span class="pre">pyuaf.client.connectionsteps</span></code></a></li>
<li><strong>sdkStatus</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.SdkStatus" title="pyuaf.util.SdkStatus"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.util.SdkStatus</span></code></a>) &#8211; The error by the SDK.</li>
<li><strong>clientSideError</strong> (<code class="docutils literal"><span class="pre">bool</span></code>) &#8211; True if the error was created inside the SDK.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True to override the error a client SDK error, False by default.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal"><span class="pre">bool</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.connectionStatusChanged">
<code class="descname">connectionStatusChanged</code><span class="sig-paren">(</span><em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.connectionStatusChanged" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method to receive connection status changes.</p>
<p>Alternatively, you can also register callback functions which you defined yourself, by
registering them using <a class="reference internal" href="#pyuaf.client.Client.registerConnectionStatusCallback" title="pyuaf.client.Client.registerConnectionStatusCallback"><code class="xref py py-meth docutils literal"><span class="pre">pyuaf.client.Client.registerConnectionStatusCallback()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>info</strong> (<a class="reference internal" href="#pyuaf.client.SessionInformation" title="pyuaf.client.SessionInformation"><code class="xref py py-class docutils literal"><span class="pre">SessionInformation</span></code></a>) &#8211; Updated session information.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.createMonitoredData">
<code class="descname">createMonitoredData</code><span class="sig-paren">(</span><em>addresses</em>, <em>notificationCallbacks=[]</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.createMonitoredData" title="Permalink to this definition">¶</a></dt>
<dd><p>Create one or more monitored data items.</p>
<p>This is a convenience function for calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-class docutils literal"><span class="pre">processRequest</span></code></a> with 
a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.CreateMonitoredDataRequest" title="pyuaf.client.requests.CreateMonitoredDataRequest"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredDataRequest</span></code></a> as its first argument.
For full flexibility, use that function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Both <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.CreateMonitoredDataRequest" title="pyuaf.client.requests.CreateMonitoredDataRequest"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredDataRequest</span></code></a> and 
<a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.CreateMonitoredEventsRequest" title="pyuaf.client.requests.CreateMonitoredEventsRequest"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredEventsRequest</span></code></a> are &#8220;persistent&#8221; requests.
It means that even when communication fails (e.g. because the server was not online),
a handle is already assigned to each monitored item as soon as you call 
createMonitoredEvents(). 
In the background, the UAF will try to (re)establish the connection, and as soon as this 
is successful, it will create the monitored items for you on the server. 
From that point on, you may start to receive notifications (that can be identified by the 
handles that were already assigned and returned to you now).
So when createMonitoredData() fails, you need to be aware that in the background the UAF
will retry to create them on the server. You can access the handles that will identify 
their notifications</p>
<blockquote class="last">
<div><ul class="simple">
<li>via the returned  <a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.CreateMonitoredDataResult" title="pyuaf.client.results.CreateMonitoredDataResult"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredDataResult</span></code></a>, in case
createMonitoredData() was successful and didn&#8217;t raise an exception</li>
<li>via the <a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.CreateMonitoredItemsError" title="pyuaf.util.errors.CreateMonitoredItemsError"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredItemsError</span></code></a> exception that was 
raised in case processRequest() was not successful. 
This exception has a 
<a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.CreateMonitoredItemsError.assignedClientHandles" title="pyuaf.util.errors.CreateMonitoredItemsError.assignedClientHandles"><code class="xref py py-attr docutils literal"><span class="pre">assignedClientHandles</span></code></a>
attribute, providing the assigned client handles.</li>
</ul>
</div></blockquote>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The callbacks will run in a separate thread, and therefore any exception they 
raise will <em>not</em> be handled or propagated. So your callbacks should have a try-except 
clause if you want to be able to properly handle the exceptions that they may raise.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addresses</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; A single address or a list of addresses, identifying the nodes to be monitored.</li>
<li><strong>notificationCallbacks</strong> (<code class="docutils literal"><span class="pre">list</span></code> of functions) &#8211; A list of callback functions (one for each node to be monitored).
These callback functions should have a single argument, which
will be of type <a class="reference internal" href="#pyuaf.client.DataChangeNotification" title="pyuaf.client.DataChangeNotification"><code class="xref py py-class docutils literal"><span class="pre">DataChangeNotification</span></code></a>.
If you don&#8217;t provide callback functions in this way, you&#8217;ll need
to override <a class="reference internal" href="#pyuaf.client.Client.dataChangesReceived" title="pyuaf.client.Client.dataChangesReceived"><code class="xref py py-meth docutils literal"><span class="pre">dataChangesReceived()</span></code></a> 
in order to receive the notifications.</li>
<li><strong>kwargs</strong> &#8211; <p>The following **kwargs are available (see <a class="reference internal" href="api_client_kwargs.html#note-client-kwargs"><span class="std std-ref">A note on **kwargs for Client services</span></a>):</p>
<ul>
<li>clientConnectionId: (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>sessionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>)</li>
<li>clientSubscriptionHandle (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>subscriptionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SubscriptionSettings" title="pyuaf.client.settings.SubscriptionSettings"><code class="xref py py-class docutils literal"><span class="pre">SubscriptionSettings</span></code></a>)</li>
<li>serviceSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.CreateMonitoredDataSettings" title="pyuaf.client.settings.CreateMonitoredDataSettings"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredDataSettings</span></code></a>)</li>
<li>translateSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings" title="pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings"><code class="xref py py-class docutils literal"><span class="pre">TranslateBrowsePathsToNodeIdsSettings</span></code></a>)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result of the CreateMonitoredData request.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.CreateMonitoredDataResult" title="pyuaf.client.results.CreateMonitoredDataResult"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredDataResult</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.createMonitoredEvents">
<code class="descname">createMonitoredEvents</code><span class="sig-paren">(</span><em>addresses</em>, <em>eventFilter=None</em>, <em>notificationCallbacks=[]</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.createMonitoredEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Create one or more monitored event items.</p>
<p>This is a convenience function for calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-class docutils literal"><span class="pre">processRequest</span></code></a> with 
a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.CreateMonitoredEventsRequest" title="pyuaf.client.requests.CreateMonitoredEventsRequest"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredEventsRequest</span></code></a> as its first argument.
For full flexibility, use that function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Both <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.CreateMonitoredDataRequest" title="pyuaf.client.requests.CreateMonitoredDataRequest"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredDataRequest</span></code></a> and 
<a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.CreateMonitoredEventsRequest" title="pyuaf.client.requests.CreateMonitoredEventsRequest"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredEventsRequest</span></code></a> are &#8220;persistent&#8221; requests.
It means that even when communication fails (e.g. because the server was not online),
a handle is already assigned to each monitored item as soon as you call 
createMonitoredEvents(). 
In the background, the UAF will try to (re)establish the connection, and as soon as this 
is successful, it will create the monitored items for you on the server. 
From that point on, you may start to receive notifications (that can be identified by the 
handles that were already assigned and returned to you now).
So when createMonitoredEvents() fails, you need to be aware that in the background the UAF
will retry to create them on the server. You can access the handles that will identify 
their notifications</p>
<blockquote class="last">
<div><ul class="simple">
<li>via the returned  <a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.CreateMonitoredEventsResult" title="pyuaf.client.results.CreateMonitoredEventsResult"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredEventsResult</span></code></a>, in case
createMonitoredEvents() was successful and didn&#8217;t raise an exception</li>
<li>via the <a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.CreateMonitoredItemsError" title="pyuaf.util.errors.CreateMonitoredItemsError"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredItemsError</span></code></a> exception that was 
raised in case processRequest() was not successful. 
This exception has a 
<a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.CreateMonitoredItemsError.assignedClientHandles" title="pyuaf.util.errors.CreateMonitoredItemsError.assignedClientHandles"><code class="xref py py-attr docutils literal"><span class="pre">assignedClientHandles</span></code></a>
attribute, providing the assigned client handles.</li>
</ul>
</div></blockquote>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The callbacks will run in a separate thread, and therefore any exception they 
raise will <em>not</em> be handled or propagated. So your callbacks should have a try-except 
clause if you want to be able to properly handle the exceptions that they may raise.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addresses</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; A single address or a list of addresses, identifying the nodes to be monitored.</li>
<li><strong>eventFilter</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.EventFilter" title="pyuaf.util.EventFilter"><code class="xref py py-class docutils literal"><span class="pre">EventFilter</span></code></a>) &#8211; The event filter, common to all nodes that you want to monitor!
If you want to specify a different filter for each target, you need to 
use the generic <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-meth docutils literal"><span class="pre">processRequest()</span></code></a> method
with a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.CreateMonitoredEventsRequest" title="pyuaf.client.requests.CreateMonitoredEventsRequest"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredEventsRequest</span></code></a> as 
argument. Leave None for defaults.</li>
<li><strong>notificationCallbacks</strong> (<code class="docutils literal"><span class="pre">list</span></code> of functions) &#8211; A list of callback functions (one for each node to be monitored).
These callback functions should have a single argument, which
will be of type <a class="reference internal" href="#pyuaf.client.EventNotification" title="pyuaf.client.EventNotification"><code class="xref py py-class docutils literal"><span class="pre">EventNotification</span></code></a>.
If you don&#8217;t provide callback functions in this way, you&#8217;ll need
to override <a class="reference internal" href="#pyuaf.client.Client.eventsReceived" title="pyuaf.client.Client.eventsReceived"><code class="xref py py-meth docutils literal"><span class="pre">eventsReceived()</span></code></a> 
in order to receive the notifications.</li>
<li><strong>kwargs</strong> &#8211; <p>The following **kwargs are available (see <a class="reference internal" href="api_client_kwargs.html#note-client-kwargs"><span class="std std-ref">A note on **kwargs for Client services</span></a>):</p>
<ul>
<li>clientConnectionId: (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>sessionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>)</li>
<li>clientSubscriptionHandle (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>subscriptionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SubscriptionSettings" title="pyuaf.client.settings.SubscriptionSettings"><code class="xref py py-class docutils literal"><span class="pre">SubscriptionSettings</span></code></a>)</li>
<li>serviceSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.CreateMonitoredEventsSettings" title="pyuaf.client.settings.CreateMonitoredEventsSettings"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredEventsSettings</span></code></a>)</li>
<li>translateSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings" title="pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings"><code class="xref py py-class docutils literal"><span class="pre">TranslateBrowsePathsToNodeIdsSettings</span></code></a>)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result of the CreateMonitoredEvents request.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.CreateMonitoredEventsResult" title="pyuaf.client.results.CreateMonitoredEventsResult"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredEventsResult</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.dataChangesReceived">
<code class="descname">dataChangesReceived</code><span class="sig-paren">(</span><em>dataNotifications</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.dataChangesReceived" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method to catch the &#8220;data change&#8221; notifications of MonitoredItems.</p>
<p>This method will only be called by the UAF if you didn&#8217;t provide &#8220;external&#8221; callback
functions already when you created the monitored items.</p>
<p>In other words, there are two ways how you can catch the data change notifications of 
monitored data items:</p>
<blockquote>
<div><ul class="simple">
<li>either by calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-meth docutils literal"><span class="pre">processRequest()</span></code></a> 
or <a class="reference internal" href="#pyuaf.client.Client.createMonitoredData" title="pyuaf.client.Client.createMonitoredData"><code class="xref py py-meth docutils literal"><span class="pre">createMonitoredData()</span></code></a> 
<em>without</em> providing external callback functions
via the &#8216;notificationCallbacks&#8217; argument 
&#8211;&gt; then you need to override <a class="reference internal" href="#pyuaf.client.Client.dataChangesReceived" title="pyuaf.client.Client.dataChangesReceived"><code class="xref py py-meth docutils literal"><span class="pre">dataChangesReceived()</span></code></a></li>
<li>or by calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-meth docutils literal"><span class="pre">processRequest()</span></code></a> 
or <a class="reference internal" href="#pyuaf.client.Client.createMonitoredData" title="pyuaf.client.Client.createMonitoredData"><code class="xref py py-meth docutils literal"><span class="pre">createMonitoredData()</span></code></a> 
<em>with</em> providing external callback functions
via the &#8216;notificationCallbacks&#8217; argument
&#8211;&gt; then only the external callback functions will be called.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dataNotifications</strong> (<code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="#pyuaf.client.DataChangeNotification" title="pyuaf.client.DataChangeNotification"><code class="xref py py-class docutils literal"><span class="pre">DataChangeNotification</span></code></a>) &#8211; The asynchronously received notifications.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.eventsReceived">
<code class="descname">eventsReceived</code><span class="sig-paren">(</span><em>eventNotifications</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.eventsReceived" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method to catch the &#8220;event&#8221; notifications of MonitoredItems.</p>
<p>This method will only be called by the UAF if you didn&#8217;t provide &#8220;external&#8221; callback
functions already when you created the monitored items.</p>
<p>In other words, there are two ways how you can catch the event notifications of 
monitored event items:</p>
<blockquote>
<div><ul class="simple">
<li>either by calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-meth docutils literal"><span class="pre">processRequest()</span></code></a> 
or <a class="reference internal" href="#pyuaf.client.Client.createMonitoredEvents" title="pyuaf.client.Client.createMonitoredEvents"><code class="xref py py-meth docutils literal"><span class="pre">createMonitoredEvents()</span></code></a> 
<em>without</em> providing external callback functions
via the &#8216;notificationCallbacks&#8217; argument 
&#8211;&gt; then you need to override <a class="reference internal" href="#pyuaf.client.Client.eventsReceived" title="pyuaf.client.Client.eventsReceived"><code class="xref py py-meth docutils literal"><span class="pre">eventsReceived()</span></code></a></li>
<li>or by calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-meth docutils literal"><span class="pre">processRequest()</span></code></a> 
or <a class="reference internal" href="#pyuaf.client.Client.createMonitoredEvents" title="pyuaf.client.Client.createMonitoredEvents"><code class="xref py py-meth docutils literal"><span class="pre">createMonitoredEvents()</span></code></a> 
<em>with</em> providing external callback functions
via the &#8216;notificationCallbacks&#8217; argument
&#8211;&gt; then only the external callback functions will be called.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>eventNotifications</strong> (<code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="#pyuaf.client.EventNotification" title="pyuaf.client.EventNotification"><code class="xref py py-class docutils literal"><span class="pre">EventNotification</span></code></a>) &#8211; The asynchronously received notifications.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.findServersNow">
<code class="descname">findServersNow</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.findServersNow" title="Permalink to this definition">¶</a></dt>
<dd><p>Discover the servers immediately (instead of waiting for the background thread) by 
using the OPC UA FindServers service.</p>
<p>The URLs to use for discovery are specified 
by the <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ClientSettings.discoveryUrls" title="pyuaf.client.settings.ClientSettings.discoveryUrls"><code class="xref py py-attr docutils literal"><span class="pre">discoveryUrls</span></code></a> attribute of the 
<a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ClientSettings" title="pyuaf.client.settings.ClientSettings"><code class="xref py py-class docutils literal"><span class="pre">ClientSettings</span></code></a>.
Since discovery is also handled silently (and periodically) in the background, 
you normally don&#8217;t have to call <a class="reference internal" href="#pyuaf.client.Client.findServersNow" title="pyuaf.client.Client.findServersNow"><code class="xref py py-meth docutils literal"><span class="pre">findServersNow()</span></code></a> manually.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.DiscoveryError" title="pyuaf.util.errors.DiscoveryError"><strong>pyuaf.util.errors.DiscoveryError</strong></a> &#8211; Raised in case the FindServers service failed for one or more URLs.</li>
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.InvalidRequestError" title="pyuaf.util.errors.InvalidRequestError"><strong>pyuaf.util.errors.InvalidRequestError</strong></a> &#8211; Raised in case the FindServers service is already being invoked by the client (because
no parallel FindServers invocations are allowed!). This can happen for instance when
multiple threads (created by the user, or running in the background of the Client
instance) try to use the FindServers service at the same time.</li>
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any other errors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.getEndpoints">
<code class="descname">getEndpoints</code><span class="sig-paren">(</span><em>discoveryUrl</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.getEndpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of endpoint descriptions supported by the server.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>discoveryUrl</strong> (<code class="docutils literal"><span class="pre">str</span></code>) &#8211; The URL of a Discovery Server (e.g. opc.tcp://mymachine:4840).</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of the endpoint descriptions that were found.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.EndpointDescription" title="pyuaf.util.EndpointDescription"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.util.EndpointDescription</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.DiscoveryError" title="pyuaf.util.errors.DiscoveryError"><strong>pyuaf.util.errors.DiscoveryError</strong></a> &#8211; Raised in case no endpoints could be retrieved.</li>
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any other errors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.historyReadModified">
<code class="descname">historyReadModified</code><span class="sig-paren">(</span><em>addresses</em>, <em>startTime</em>, <em>endTime</em>, <em>numValuesPerNode=0</em>, <em>maxAutoReadMore=0</em>, <em>continuationPoints=[]</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.historyReadModified" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the modification information of the historical data from one or more nodes
synchronously.</p>
<p>This is a convenience function for calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-class docutils literal"><span class="pre">processRequest</span></code></a> with 
a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.HistoryReadRawModifiedRequest" title="pyuaf.client.requests.HistoryReadRawModifiedRequest"><code class="xref py py-class docutils literal"><span class="pre">HistoryReadRawModifiedRequest</span></code></a> as its first argument.
For full flexibility, use that function.</p>
<p>Since this convenience method is meant to fetch the modification info of historical data, 
the <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.HistoryReadRawModifiedSettings.isReadModified" title="pyuaf.client.settings.HistoryReadRawModifiedSettings.isReadModified"><code class="xref py py-attr docutils literal"><span class="pre">isReadModified</span></code></a>
flag of the serviceSettings will be forced to True!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addresses</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> of 
<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; A single address or a list of addresses of nodes of which the 
historical data should be retrieved.</li>
<li><strong>startTime</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.DateTime" title="pyuaf.util.DateTime"><code class="xref py py-class docutils literal"><span class="pre">DateTime</span></code></a>) &#8211; The start time of the interval from which you would like
to see the historical data. This parameter will always be used 
instead of the startTime attribute of the serviceSettings .</li>
<li><strong>endTime</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.DateTime" title="pyuaf.util.DateTime"><code class="xref py py-class docutils literal"><span class="pre">DateTime</span></code></a>) &#8211; The end time of the interval from which you would like
to see the historical data. This parameter will always be used 
instead of the startTime attribute of the serviceSettings .</li>
<li><strong>numValuesPerNode</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The maximum number of values that may be returned for each
node. 0 means no limit, but you may want to put it to a
&#8220;safe&#8221; value (e.g. 100 if you expect to receive at most
50 historical values or so) to make sure that you&#8217;re not
flooded by a huge stream of data values, e.g. in case you&#8217;ve
made some mistake in the time interval!
Default = 0.</li>
<li><strong>maxAutoReadMore</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; How many times do you allow the UAF to automatically invoke
a &#8220;continuation request&#8221; for you (if that&#8217;s needed to fetch
all results)? E.g. if you specify maxAutoReadMore = 10,
then the UAF will automatically perform subsequent
history requests, until either all results are fetched, or
until 10 additional requests have been invoked
automatically.
This parameter will always be used instead of the
maxAutoReadMore attribute of the serviceSettings.
Default = 0, which means that no &#8220;automatic&#8221; continuation 
requests will be invoked by the UAF (so if you leave this
parameter as 0 and you see that the 
len(result.targets[x].continuationPoint) &gt; 0, then you must
call the historyReadRaw method again with this continuationPoint
to receive more historical data).</li>
<li><strong>continuationPoints</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.ByteStringVector" title="pyuaf.util.ByteStringVector"><code class="xref py py-class docutils literal"><span class="pre">ByteStringVector</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> of 
Python <code class="docutils literal"><span class="pre">bytearray</span></code> objects.) &#8211; Continuation points, in case you&#8217;re continuing to read the
istorical data of a previous request manually. By
specifying a sufficiently large number for maxAutoReadMore,
you can actually let the UAF handle the &#8220;continuation
requests&#8221;, if you want. If you&#8217;re not using
continuationPoints manually, you can simply provide an
empty list or vector.
Default = empty list.</li>
<li><strong>kwargs</strong> &#8211; <p>The following **kwargs are available (see <a class="reference internal" href="api_client_kwargs.html#note-client-kwargs"><span class="std std-ref">A note on **kwargs for Client services</span></a>):</p>
<ul>
<li>clientConnectionId: (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>sessionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>)</li>
<li>serviceSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.HistoryReadRawModifiedSettings" title="pyuaf.client.settings.HistoryReadRawModifiedSettings"><code class="xref py py-class docutils literal"><span class="pre">HistoryReadRawModifiedSettings</span></code></a>)</li>
<li>translateSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings" title="pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings"><code class="xref py py-class docutils literal"><span class="pre">TranslateBrowsePathsToNodeIdsSettings</span></code></a>)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result of the history read request.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.HistoryReadRawModifiedResult" title="pyuaf.client.results.HistoryReadRawModifiedResult"><code class="xref py py-class docutils literal"><span class="pre">HistoryReadRawModifiedResult</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.historyReadRaw">
<code class="descname">historyReadRaw</code><span class="sig-paren">(</span><em>addresses</em>, <em>startTime</em>, <em>endTime</em>, <em>numValuesPerNode=0</em>, <em>maxAutoReadMore=0</em>, <em>continuationPoints=[]</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.historyReadRaw" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the raw historical data from one or more nodes synchronously.</p>
<p>This is a convenience function for calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-class docutils literal"><span class="pre">processRequest</span></code></a> with 
a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.HistoryReadRawModifiedRequest" title="pyuaf.client.requests.HistoryReadRawModifiedRequest"><code class="xref py py-class docutils literal"><span class="pre">HistoryReadRawModifiedRequest</span></code></a> as its first argument.
For full flexibility, use that function.</p>
<p>Since this convenience method is meant to fetch raw historical data, the 
<a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.HistoryReadRawModifiedSettings.isReadModified" title="pyuaf.client.settings.HistoryReadRawModifiedSettings.isReadModified"><code class="xref py py-attr docutils literal"><span class="pre">isReadModified</span></code></a>
flag of the serviceSettings will be forced to False!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addresses</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> of 
<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; A single address or a list of addresses of nodes of which the 
historical data should be retrieved.</li>
<li><strong>startTime</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.DateTime" title="pyuaf.util.DateTime"><code class="xref py py-class docutils literal"><span class="pre">DateTime</span></code></a>) &#8211; The start time of the interval from which you would like
to see the historical data. This parameter will always be used 
instead of the startTime attribute of the serviceSettings.</li>
<li><strong>endTime</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.DateTime" title="pyuaf.util.DateTime"><code class="xref py py-class docutils literal"><span class="pre">DateTime</span></code></a>) &#8211; The end time of the interval from which you would like
to see the historical data. This parameter will always be used 
instead of the startTime attribute of the serviceSettings.</li>
<li><strong>numValuesPerNode</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The maximum number of values that may be returned for each
node. 0 means no limit, but you may want to put it to a
&#8220;safe&#8221; value (e.g. 100 if you expect to receive at most
50 historical values or so) to make sure that you&#8217;re not
flooded by a huge stream of data values, e.g. in case you&#8217;ve
made some mistake in the time interval!
Default = 0.</li>
<li><strong>maxAutoReadMore</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; How many times do you allow the UAF to automatically invoke
a &#8220;continuation request&#8221; for you (if that&#8217;s needed to fetch
all results)? E.g. if you specify maxAutoReadMore = 10,
then the UAF will automatically perform subsequent
history requests, until either all results are fetched, or
until 10 additional requests have been invoked
automatically.
This parameter will always be used instead of the
maxAutoReadMore attribute of the serviceSettings.
Default = 0, which means that no &#8220;automatic&#8221; continuation 
requests will be invoked by the UAF (so if you leave this
parameter as 0 and you see that the 
len(result.targets[x].continuationPoint) &gt; 0, then you must
call the historyReadRaw method again with this continuationPoint
to receive more historical data).</li>
<li><strong>continuationPoints</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.ByteStringVector" title="pyuaf.util.ByteStringVector"><code class="xref py py-class docutils literal"><span class="pre">ByteStringVector</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> of 
Python <code class="docutils literal"><span class="pre">bytearray</span></code> objects.) &#8211; Continuation points, in case you&#8217;re continuing to read the
istorical data of a previous request manually. By
specifying a sufficiently large number for maxAutoReadMore,
you can actually let the UAF handle the &#8220;continuation
requests&#8221;, if you want. If you&#8217;re not using
continuationPoints manually, you can simply provide an
empty list or vector.
Default = empty list.</li>
<li><strong>kwargs</strong> &#8211; <p>The following **kwargs are available (see <a class="reference internal" href="api_client_kwargs.html#note-client-kwargs"><span class="std std-ref">A note on **kwargs for Client services</span></a>):</p>
<ul>
<li>clientConnectionId: (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>sessionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>)</li>
<li>serviceSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.HistoryReadRawModifiedSettings" title="pyuaf.client.settings.HistoryReadRawModifiedSettings"><code class="xref py py-class docutils literal"><span class="pre">HistoryReadRawModifiedSettings</span></code></a>)</li>
<li>translateSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings" title="pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings"><code class="xref py py-class docutils literal"><span class="pre">TranslateBrowsePathsToNodeIdsSettings</span></code></a>)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result of the history read request.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.HistoryReadRawModifiedResult" title="pyuaf.client.results.HistoryReadRawModifiedResult"><code class="xref py py-class docutils literal"><span class="pre">HistoryReadRawModifiedResult</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.keepAliveReceived">
<code class="descname">keepAliveReceived</code><span class="sig-paren">(</span><em>notification</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.keepAliveReceived" title="Permalink to this definition">¶</a></dt>
<dd><p>You should override this method if you want to process keep alive messages from the UAF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>notification</strong> (<a class="reference internal" href="#pyuaf.client.KeepAliveNotification" title="pyuaf.client.KeepAliveNotification"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.KeepAliveNotification</span></code></a>) &#8211; The received KeepAliveNotification.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.logMessageReceived">
<code class="descname">logMessageReceived</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.logMessageReceived" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method if you want to process logging output from the UAF.</p>
<dl class="docutils">
<dt>This method is called by the UAF if:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ClientSettings.logToCallbackLevel" title="pyuaf.client.settings.ClientSettings.logToCallbackLevel"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.client.settings.ClientSettings.logToCallbackLevel</span></code></a> is not set to <a class="reference internal" href="api_pyuaf_util_loglevels.html#pyuaf.util.loglevels.Disabled" title="pyuaf.util.loglevels.Disabled"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.loglevels.Disabled</span></code></a></li>
<li>no external logging callback function is registered 
(via <a class="reference internal" href="#pyuaf.client.Client" title="pyuaf.client.Client"><code class="xref py py-meth docutils literal"><span class="pre">Client()</span></code></a> or via <a class="reference internal" href="#pyuaf.client.Client.registerLoggingCallback" title="pyuaf.client.Client.registerLoggingCallback"><code class="xref py py-meth docutils literal"><span class="pre">registerLoggingCallback()</span></code></a>).</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>message</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.LogMessage" title="pyuaf.util.LogMessage"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.util.LogMessage</span></code></a>) &#8211; The received LogMessage.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.manuallyConnect">
<code class="descname">manuallyConnect</code><span class="sig-paren">(</span><em>serverUri</em>, <em>sessionSettings=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.manuallyConnect" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a session manually (instead of having the UAF do it behind the scenes).</p>
<p>One of the advantages of the UAF is that you can just define the addresses of some nodes, and 
then read/write/monitor/... them without worrying about the technical concerns such as
session creation, subscription creation etc. So you don&#8217;t have to create sessions
yourself, because the UAF will do it for you.
However, if you want to &#8220;keep control&#8221; over the session/subscription/... management
yourself, you can use methods like 
<a class="reference internal" href="#pyuaf.client.Client.manuallyConnect" title="pyuaf.client.Client.manuallyConnect"><code class="xref py py-meth docutils literal"><span class="pre">manuallyConnect()</span></code></a>, 
<a class="reference internal" href="#pyuaf.client.Client.manuallyDisconnect" title="pyuaf.client.Client.manuallyDisconnect"><code class="xref py py-meth docutils literal"><span class="pre">manuallyDisconnect()</span></code></a>,
<a class="reference internal" href="#pyuaf.client.Client.manuallySubscribe" title="pyuaf.client.Client.manuallySubscribe"><code class="xref py py-meth docutils literal"><span class="pre">manuallySubscribe()</span></code></a>, etc. 
In this case, you can create the sessions/subscriptions/...
in advance, and then afterwards read/write/... variables by using the same sessions
and subscriptions. So these &#8220;manual&#8221; methods allow you to use OPC UA in the &#8220;traditional
way&#8221;, however it&#8217;s much easier to do it the &#8220;UAF way&#8221; and simply forget about the
creation and deletion of sessions, subscriptions, and monitored items.</p>
<p>The URL(s) needed to discover the server with the given server URI, can be specified 
via the <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ClientSettings" title="pyuaf.client.settings.ClientSettings"><code class="xref py py-class docutils literal"><span class="pre">ClientSettings</span></code></a> (which you can set via 
<a class="reference internal" href="#pyuaf.client.Client" title="pyuaf.client.Client"><code class="xref py py-meth docutils literal"><span class="pre">Client()</span></code></a> and via <a class="reference internal" href="#pyuaf.client.Client.setClientSettings" title="pyuaf.client.Client.setClientSettings"><code class="xref py py-meth docutils literal"><span class="pre">setClientSettings()</span></code></a>).</p>
<blockquote>
<div><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>If the connection fails (e.g. because you specified a wrong server URI, or because
the security settings were incorrect), this methd will <em>not</em> raise an Exception! 
It will simply return the ClientConnectionId assigned to the internal Session object, 
which the UAF will try to reconnect in the background! So if you want to make sure
this method call resulted in a connected session, you should do something like this:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="n">clientConnectionId</span> <span class="o">=</span> <span class="n">myClient</span><span class="o">.</span><span class="n">manuallyConnect</span><span class="p">(</span><span class="n">SERVER_URI</span><span class="p">)</span>
<span class="n">sessionInformation</span> <span class="o">=</span> <span class="n">myClient</span><span class="o">.</span><span class="n">sessionInformation</span><span class="p">(</span><span class="n">clientConnectionId</span><span class="p">)</span>
<span class="k">if</span> <span class="n">sessionInformation</span><span class="o">.</span><span class="n">sessionState</span> <span class="o">==</span> <span class="n">pyuaf</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">sessionstates</span><span class="o">.</span><span class="n">Disconnected</span><span class="p">:</span>
    <span class="k">pass</span> <span class="c1"># OK, we can proceed</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Oops, something went wrong:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sessionInformation</span><span class="o">.</span><span class="n">lastConnectionAttemptStatus</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>serverUri</strong> (<code class="docutils literal"><span class="pre">str</span></code>) &#8211; The server URI to manually connect to.</li>
<li><strong>sessionSettings</strong> (<a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>) &#8211; The settings for the session (leave None for a default instance).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The client connection id: a number identifying the session.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="docutils literal"><span class="pre">int</span></code></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.DiscoveryError" title="pyuaf.util.errors.DiscoveryError"><strong>pyuaf.util.errors.DiscoveryError</strong></a> &#8211; Raised in case the FindServers service failed to discover a server that matches the 
given server URI.</li>
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any other errors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.manuallyConnectToEndpoint">
<code class="descname">manuallyConnectToEndpoint</code><span class="sig-paren">(</span><em>endpointUrl</em>, <em>sessionSettings=None</em>, <em>serverCertificate=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.manuallyConnectToEndpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Manually connect to a specific endpoint, without using the discovery services.</p>
<p>A UAF client normally uses the discovery process to identify a server and connect to it.
The user therefore doesn&#8217;t have to worry about connecting, disconnecting, session management, etc.</p>
<p>However, in certain cases you may want to connect manually to a specific endpoint, without using
the discovery process (i.e. without relying on the discovery endpoint of the server).
In these cases you can use this method.</p>
<p>You should probably only use this method if you have a good reason not to rely on
the discovery services provided by the server. A server should be identified by
a serverURI, not by an endpointURL!</p>
<p>The <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings.securitySettings" title="pyuaf.client.settings.SessionSettings.securitySettings"><code class="xref py py-attr docutils literal"><span class="pre">securitySettings</span></code></a> attribute of the 
sessionSettings argument (in other words: sessionSettings.securitySettings) defines 
how you want to connect to the server.</p>
<dl class="docutils">
<dt>This default instance has </dt>
<dd><ul class="first last simple">
<li>no security policy (<a class="reference internal" href="api_pyuaf_util_securitypolicies.html#pyuaf.util.securitypolicies.UA_None" title="pyuaf.util.securitypolicies.UA_None"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.securitypolicies.UA_None</span></code></a>)</li>
<li>no security mode (<a class="reference internal" href="api_pyuaf_util_messagesecuritymodes.html#pyuaf.util.messagesecuritymodes.Mode_None" title="pyuaf.util.messagesecuritymodes.Mode_None"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.messagesecuritymodes.Mode_None</span></code></a>)</li>
<li>no authentication (<a class="reference internal" href="api_pyuaf_util_usertokentypes.html#pyuaf.util.usertokentypes.Anonymous" title="pyuaf.util.usertokentypes.Anonymous"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.usertokentypes.Anonymous</span></code></a>)</li>
</ul>
</dd>
</dl>
<p>Compliant to OPC UA specs, the serverCertificate will:</p>
<ul class="simple">
<li>first be checked at the application level. If it&#8217;s not valid or not found in the trust
list, then the untrustedServerCertificateReceived() callback function will be called.
Override this method if you want to handle those cases.</li>
<li>then it may be used for encryption and/or signing (if a secure connection is needed,
of course).</li>
</ul>
<p>You can leave serverCertificate <code class="docutils literal"><span class="pre">None</span></code> (or provide a default, invalid, null 
<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate" title="pyuaf.util.PkiCertificate"><code class="xref py py-class docutils literal"><span class="pre">PkiCertificate</span></code></a> instance) if you trust the server (i.e. if you make sure
<a class="reference internal" href="#pyuaf.client.Client.untrustedServerCertificateReceived" title="pyuaf.client.Client.untrustedServerCertificateReceived"><code class="xref py py-meth docutils literal"><span class="pre">untrustedServerCertificateReceived()</span></code></a> 
returns <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_AcceptTemporarily" title="pyuaf.util.PkiCertificate.Action_AcceptTemporarily"><code class="xref py py-attr docutils literal"><span class="pre">Action_AcceptTemporarily</span></code></a>),
and if you don&#8217;t need signing or encryption.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If this method fails (in other words, when an Error is raised), then no
Session has been created! This is different behavior from 
<a class="reference internal" href="#pyuaf.client.Client.manuallyConnect" title="pyuaf.client.Client.manuallyConnect"><code class="xref py py-meth docutils literal"><span class="pre">manuallyConnect()</span></code></a>, which will have created a Session that
automatically retries to connect.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Check out example <a class="reference internal" href="client_examples.html#manual-connection-to-endpoint"><span class="std std-ref">How to manually connect to an endpoint without discovery?</span></a> for more information.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>endpointUrl</strong> &#8211; The endpoint URL to manually connect to.</li>
<li><strong>sessionSettings</strong> (<a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>) &#8211; The settings for the session (leave None for a default instance).</li>
<li><strong>serverCertificate</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate" title="pyuaf.util.PkiCertificate"><code class="xref py py-class docutils literal"><span class="pre">PkiCertificate</span></code></a>) &#8211; The server certificate (will be checked!)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The client connection id: a number identifying the session.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="docutils literal"><span class="pre">int</span></code></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.ConnectionError" title="pyuaf.util.errors.ConnectionError"><strong>pyuaf.util.errors.ConnectionError</strong></a> &#8211; Raised in case the connection fails.</li>
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any other errors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.manuallyDisconnect">
<code class="descname">manuallyDisconnect</code><span class="sig-paren">(</span><em>clientConnectionId</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.manuallyDisconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnect the session manually.</p>
<p>A session which has been disconnected manually is &#8220;garbage collected&#8221; on the client side.
When a session is created afterwards, a new ClientConnectionId will be assigned to this
session (even if the properties of the new session are exactly the same as the old one).</p>
<p>Only use this for sessions that were created via the manuallyConnect method!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>clientConnectionId</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The id of the session (that was returned by
the <a class="reference internal" href="#pyuaf.client.Client.manuallyConnect" title="pyuaf.client.Client.manuallyConnect"><code class="xref py py-meth docutils literal"><span class="pre">manuallyConnect()</span></code></a> method).</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.InvalidRequestError" title="pyuaf.util.errors.InvalidRequestError"><strong>pyuaf.util.errors.InvalidRequestError</strong></a> &#8211; Raised in case no session is known for the given client connection id.</li>
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any other errors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.manuallyDisconnectAllSessions">
<code class="descname">manuallyDisconnectAllSessions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.manuallyDisconnectAllSessions" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnect all sessions.</p>
<p>To stress that normally the UAF takes care of session connection and disconnection,
this method has a &#8220;manually&#8221; prefix. Normally it should not be used explicitely,
as all sessions will be disconnected automatically when the client is deleted.</p>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.manuallySubscribe">
<code class="descname">manuallySubscribe</code><span class="sig-paren">(</span><em>clientConnectionId</em>, <em>subscriptionSettings=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.manuallySubscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a subscription manually.</p>
<p>For more info about &#8220;manual&#8221; methods, see the documentation on the
<a class="reference internal" href="#pyuaf.client.Client.manuallyConnect" title="pyuaf.client.Client.manuallyConnect"><code class="xref py py-meth docutils literal"><span class="pre">manuallyConnect()</span></code></a> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clientConnectionId</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The id of the session which should host the subscription.</li>
<li><strong>settings</strong> (<a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SubscriptionSettings" title="pyuaf.client.settings.SubscriptionSettings"><code class="xref py py-class docutils literal"><span class="pre">SubscriptionSettings</span></code></a>) &#8211; The settings of the subscription you&#8217;d like to create.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The clientSubscriptionHandle: the handle identifying the newly
created subscription.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="docutils literal"><span class="pre">int</span></code></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any other errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.manuallyUnsubscribe">
<code class="descname">manuallyUnsubscribe</code><span class="sig-paren">(</span><em>clientConnectionId</em>, <em>clientSubscriptionHandle</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.manuallyUnsubscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the subscription manually.</p>
<p>A subscription which has been deleted manually is &#8220;garbage collected&#8221; on the client side.
When a subscription is created afterwards, a new clientSubscriptionHandle will be assigned to this
session (even if the properties of the new subscription are exactly the same as the old one).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clientConnectionId</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The id of the session that hosts the subscription.</li>
<li><strong>clientSubscriptionHandle</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The id of the subscription.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.InvalidRequestError" title="pyuaf.util.errors.InvalidRequestError"><strong>pyuaf.util.errors.InvalidRequestError</strong></a> &#8211; Raised in case no session is known for the given clientSubscriptionHandle.</li>
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any other errors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.monitoredItemInformation">
<code class="descname">monitoredItemInformation</code><span class="sig-paren">(</span><em>clientHandle</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.monitoredItemInformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Get information about the specified monitored item.</p>
<p>Check the <a class="reference internal" href="#pyuaf.client.MonitoredItemInformation.monitoredItemState" title="pyuaf.client.MonitoredItemInformation.monitoredItemState"><code class="xref py py-attr docutils literal"><span class="pre">monitoredItemState</span></code></a> before 
interpreting the results of the <a class="reference internal" href="#pyuaf.client.MonitoredItemInformation" title="pyuaf.client.MonitoredItemInformation"><code class="xref py py-class docutils literal"><span class="pre">MonitoredItemInformation</span></code></a>!
Because if the <a class="reference internal" href="#pyuaf.client.MonitoredItemInformation.monitoredItemState" title="pyuaf.client.MonitoredItemInformation.monitoredItemState"><code class="xref py py-attr docutils literal"><span class="pre">monitoredItemState</span></code></a> is 
<a class="reference internal" href="api_pyuaf_client_monitoreditemstates.html#pyuaf.client.monitoreditemstates.NotCreated" title="pyuaf.client.monitoreditemstates.NotCreated"><code class="xref py py-attr docutils literal"><span class="pre">NotCreated</span></code></a>, then the monitored item not created on
the server, but instead it&#8217;s cached by the client (which tries to re-create the monitored
item periodically -as configurable by the <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ClientSettings" title="pyuaf.client.settings.ClientSettings"><code class="xref py py-class docutils literal"><span class="pre">ClientSettings</span></code></a>-).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>clientHandle</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The handle of the monitored item (always assigned by the UAF, not 
by the user!). This clientHandle is assigned when the monitored item 
is requested (e.g. by calling <a class="reference internal" href="#pyuaf.client.Client.createMonitoredData" title="pyuaf.client.Client.createMonitoredData"><code class="xref py py-meth docutils literal"><span class="pre">createMonitoredData()</span></code></a>),
regardless of whether the monitored items were indeed created on the server,
or not (e.g. in case of failures, or in case the server is not on-line yet).</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Information about the specified monitored item.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#pyuaf.client.MonitoredItemInformation" title="pyuaf.client.MonitoredItemInformation"><code class="xref py py-class docutils literal"><span class="pre">MonitoredItemInformation</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UnknownClientHandleError" title="pyuaf.util.errors.UnknownClientHandleError"><strong>pyuaf.util.errors.UnknownClientHandleError</strong></a> &#8211; Raised in case no monitored item is known for the given client handle.</li>
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any other errors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.notificationsMissing">
<code class="descname">notificationsMissing</code><span class="sig-paren">(</span><em>info</em>, <em>previousSequenceNumber</em>, <em>newSequenceNumber</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.notificationsMissing" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method to handle missing notifications.</p>
<p>Alternatively, you can also register callback functions which you defined yourself, by
registering them using <a class="reference internal" href="#pyuaf.client.Client.registerNotificationsMissingCallback" title="pyuaf.client.Client.registerNotificationsMissingCallback"><code class="xref py py-meth docutils literal"><span class="pre">pyuaf.client.Client.registerNotificationsMissingCallback()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>info</strong> (<a class="reference internal" href="#pyuaf.client.SubscriptionInformation" title="pyuaf.client.SubscriptionInformation"><code class="xref py py-class docutils literal"><span class="pre">SubscriptionInformation</span></code></a>) &#8211; Subscription information about the subscription which has missing notifications.</li>
<li><strong>previousSequenceNumber</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; Sequence number of the last notification just before 
notifications went missing.</li>
<li><strong>newSequenceNumber</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; Sequence number of the first notification just after notifications
went missing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.processRequest">
<code class="descname">processRequest</code><span class="sig-paren">(</span><em>request</em>, <em>resultCallback=None</em>, <em>notificationCallbacks=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.processRequest" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a generic request (as found in <a class="reference internal" href="api_pyuaf_client_requests.html#module-pyuaf.client.requests" title="pyuaf.client.requests"><code class="xref py py-mod docutils literal"><span class="pre">pyuaf.client.requests</span></code></a>).</p>
<dl class="docutils">
<dt>As for callbacks, you may:</dt>
<dd><ul class="first last simple">
<li>specify no callbacks at all. In this case, you need to override (&#8220;virtually inherit&#8221;)
the <a class="reference internal" href="#pyuaf.client.Client.readComplete" title="pyuaf.client.Client.readComplete"><code class="xref py py-meth docutils literal"><span class="pre">readComplete()</span></code></a>/<a class="reference internal" href="#pyuaf.client.Client.writeComplete" title="pyuaf.client.Client.writeComplete"><code class="xref py py-meth docutils literal"><span class="pre">writeComplete()</span></code></a>/<a class="reference internal" href="#pyuaf.client.Client.dataChangesReceived" title="pyuaf.client.Client.dataChangesReceived"><code class="xref py py-meth docutils literal"><span class="pre">dataChangesReceived()</span></code></a>/... functions</li>
<li>specify a resultCallback function (only for AsyncXXXXX functions!). 
In this case, the ReadResult/WriteResult/MethodCallResult/...
of the corresponding asynchronous requests will be forwarded to the resultCallback
function.</li>
<li>specify a list of notificationCallback functions (only for CreateMonitoredDataRequests,
CreateMonitoredEventsRequests, AsyncCreateMonitoredDataRequests and 
AsyncCreateMonitoredEventsRequests!). The number of callbacks must correspond exactly to
the number of targets of the request.</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Both <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.CreateMonitoredDataRequest" title="pyuaf.client.requests.CreateMonitoredDataRequest"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredDataRequest</span></code></a> and 
<a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.CreateMonitoredEventsRequest" title="pyuaf.client.requests.CreateMonitoredEventsRequest"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredEventsRequest</span></code></a> are &#8220;persistent&#8221; requests.
It means that even when communication fails (e.g. because the server was not online),
a handle is already assigned to each monitored item as soon as you call processRequest(). 
In the background, the UAF will try to (re)establish the connection, and as soon as this 
is successful, it will create the monitored items for you on the server. 
From that point on, you may start to receive notifications (that can be identified by the 
handles that were already assigned and returned to you now).
So when processRequest() fails, you need to be aware that in the background the UAF
will retry to create them on the server. You can access the handles that will identify 
their notifications:</p>
<blockquote class="last">
<div><ul class="simple">
<li>via the returned <a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.CreateMonitoredDataResult" title="pyuaf.client.results.CreateMonitoredDataResult"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredDataResult</span></code></a> (or
<a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.CreateMonitoredEventsResult" title="pyuaf.client.results.CreateMonitoredEventsResult"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredEventsResult</span></code></a>), in case
processRequest() was successful and didn&#8217;t raise an exception</li>
<li>via the <a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.CreateMonitoredItemsError" title="pyuaf.util.errors.CreateMonitoredItemsError"><code class="xref py py-class docutils literal"><span class="pre">CreateMonitoredItemsError</span></code></a> exception that was 
raised in case processRequest() was not successful. 
This exception has a 
<a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.CreateMonitoredItemsError.assignedClientHandles" title="pyuaf.util.errors.CreateMonitoredItemsError.assignedClientHandles"><code class="xref py py-attr docutils literal"><span class="pre">assignedClientHandles</span></code></a>
attribute, providing the assigned client handles.</li>
</ul>
</div></blockquote>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Asynchronous requests MUST be invoked on a single session. Meaning:
the targets of asynchronous requests MUST belong to the same server (as the UAF can 
currently not reconstruct an asynchronous request that must be &#8220;split up&#8221; to be called
on multiple servers). If they don&#8217;t belong to the same server, an error will be raised.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The callbacks will run in a separate thread, and therefore any exception they 
raise will <em>not</em> be handled or propagated. So your callbacks should have a try-except 
clause if you want to be able to properly handle the exceptions that they may raise.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>request</strong> &#8211; The request (e.g. a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.ReadRequest" title="pyuaf.client.requests.ReadRequest"><code class="xref py py-class docutils literal"><span class="pre">ReadRequest</span></code></a> 
or class:<cite>~pyuaf.client.requests.WriteRequest</cite> or ...</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The result of the request (e.g. a <a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.ReadResult" title="pyuaf.client.results.ReadResult"><code class="xref py py-class docutils literal"><span class="pre">ReadResult</span></code></a> 
or <a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.WriteResult" title="pyuaf.client.results.WriteResult"><code class="xref py py-class docutils literal"><span class="pre">WriteResult</span></code></a> or ...</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>addresses</em>, <em>attributeId=13</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a number of node attributes synchronously.</p>
<p>This is a convenience function for calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-class docutils literal"><span class="pre">processRequest</span></code></a> with 
a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.ReadRequest" title="pyuaf.client.requests.ReadRequest"><code class="xref py py-class docutils literal"><span class="pre">ReadRequest</span></code></a> as its first argument.
For full flexibility, use that function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addresses</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; A single address or a list of addresses of nodes of which the specified 
attribute should be read.</li>
<li><strong>attributeId</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The id of the attribute to be read (e.g. <a class="reference internal" href="api_pyuaf_util_attributeids.html#pyuaf.util.attributeids.Value" title="pyuaf.util.attributeids.Value"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.attributeids.Value</span></code></a>
or <a class="reference internal" href="api_pyuaf_util_attributeids.html#pyuaf.util.attributeids.DisplayName" title="pyuaf.util.attributeids.DisplayName"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.attributeids.DisplayName</span></code></a>).</li>
<li><strong>kwargs</strong> &#8211; <p>The following **kwargs are available (see <a class="reference internal" href="api_client_kwargs.html#note-client-kwargs"><span class="std std-ref">A note on **kwargs for Client services</span></a>):</p>
<ul>
<li>clientConnectionId: (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>sessionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>)</li>
<li>serviceSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ReadSettings" title="pyuaf.client.settings.ReadSettings"><code class="xref py py-class docutils literal"><span class="pre">ReadSettings</span></code></a>)</li>
<li>translateSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings" title="pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings"><code class="xref py py-class docutils literal"><span class="pre">TranslateBrowsePathsToNodeIdsSettings</span></code></a>)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result of the read request.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.ReadResult" title="pyuaf.client.results.ReadResult"><code class="xref py py-class docutils literal"><span class="pre">ReadResult</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.readComplete">
<code class="descname">readComplete</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.readComplete" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method to catch the result of asynchronous read requests.</p>
<p>This method will only be called by the UAF if you didn&#8217;t provide an &#8220;external&#8221; callback
function already when you began the asynchronous read request.</p>
<p>In other words, there are two ways how you can catch the result of asynchronous read requests:</p>
<blockquote>
<div><ul class="simple">
<li>either by calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-meth docutils literal"><span class="pre">processRequest()</span></code></a> or <cite>:meth:~pyuaf.client.Client.beginRead</cite> 
<em>without</em> providing an external callback function &#8211;&gt; then you need to override 
<a class="reference internal" href="#pyuaf.client.Client.readComplete" title="pyuaf.client.Client.readComplete"><code class="xref py py-meth docutils literal"><span class="pre">readComplete()</span></code></a></li>
<li>or by calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-meth docutils literal"><span class="pre">processRequest()</span></code></a> <em>with</em> providing an external 
callback function &#8211;&gt; then only the external callback function will be called.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>result</strong> (<a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.ReadResult" title="pyuaf.client.results.ReadResult"><code class="xref py py-class docutils literal"><span class="pre">ReadResult</span></code></a>) &#8211; The asynchronously received read result.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.registerConnectErrorCallback">
<code class="descname">registerConnectErrorCallback</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.registerConnectErrorCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback function to handle connect errors.</p>
<p>If you register a callback function, this callback function will be called instead of 
the <a class="reference internal" href="#pyuaf.client.Client.connectErrorReceived" title="pyuaf.client.Client.connectErrorReceived"><code class="xref py py-meth docutils literal"><span class="pre">connectErrorReceived()</span></code></a> function 
(so the latter function will NOT be called anymore!).</p>
<p>The callback function should have:</p>
<ul class="simple">
<li>4 input arguments: clientConnectionId, connectionStep, sdkStatus, clientSideError</li>
<li>1 returned value: a bool</li>
</ul>
<p>The signature of this method (and the meaning of these input arguments and returned value)
is exactly the same as <a class="reference internal" href="#pyuaf.client.Client.connectErrorReceived" title="pyuaf.client.Client.connectErrorReceived"><code class="xref py py-meth docutils literal"><span class="pre">connectErrorReceived()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>callback</strong> &#8211; A callback function for handling connectErrors.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.registerConnectionStatusCallback">
<code class="descname">registerConnectionStatusCallback</code><span class="sig-paren">(</span><em>callback</em>, <em>onlyServerUri=None</em>, <em>onlyClientConnectionId=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.registerConnectionStatusCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback to receive connection status changes.</p>
<p>You can register multiple callbacks: all of them will be called.
The <a class="reference internal" href="#pyuaf.client.Client.connectionStatusChanged" title="pyuaf.client.Client.connectionStatusChanged"><code class="xref py py-meth docutils literal"><span class="pre">pyuaf.client.Client.connectionStatusChanged()</span></code></a> method (which you may override) 
will also always be called, regardless of the callbacks you register.</p>
<p>There&#8217;s no need to provide more than one optional argument (it doesn&#8217;t make much sense in fact,
since onlyClientConnectionId is more restrictive than onlyServerUri), but it&#8217;s not forbidden
either. In case you provide multiple optional arguments, all of the conditions need to 
be satisfied for the callback function to be called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>callback</strong> &#8211; A callback function. This function should have one input 
argument, to which the changed <a class="reference internal" href="#pyuaf.client.SessionInformation" title="pyuaf.client.SessionInformation"><code class="xref py py-class docutils literal"><span class="pre">SessionInformation</span></code></a> 
instance will be passed.</li>
<li><strong>onlyServerUri</strong> (<code class="docutils literal"><span class="pre">str</span></code>) &#8211; Optional argument: provide this argument if you don&#8217;t want 
to listen to the status changes of <em>all</em> sessions to <em>any</em> server, 
but only listen to the connection changes for all sessions 
to the server identified by the given serverUri.</li>
<li><strong>onlyClientConnectionId</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; Optional argument: provide this argument if you don&#8217;t want 
to listen to the status changes of <em>all</em> sessions to <em>any</em> server, 
but only listen to the connection changes for the single session 
identified by the given unique clientConnectionId.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.registerKeepAliveCallback">
<code class="descname">registerKeepAliveCallback</code><span class="sig-paren">(</span><em>callback</em>, <em>onlyClientSubscriptionHandle=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.registerKeepAliveCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback to handle KeepAlive notifications.</p>
<p>You can register multiple callbacks: all of them will be called.
The <a class="reference internal" href="#pyuaf.client.Client.keepAliveReceived" title="pyuaf.client.Client.keepAliveReceived"><code class="xref py py-meth docutils literal"><span class="pre">pyuaf.client.Client.keepAliveReceived()</span></code></a> method (which you may override) 
will also always be called, regardless of the callbacks you register.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>callback</strong> &#8211; A callback function. This function should have one input
argument of type <a class="reference internal" href="#pyuaf.client.KeepAliveNotification" title="pyuaf.client.KeepAliveNotification"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.KeepAliveNotification</span></code></a>.</li>
<li><strong>onlyClientSubscriptionHandle</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; Optional argument: provide this argument if you don&#8217;t 
want to listen to the KeepAlive notifications of <em>all</em> 
subscriptions, but only listen to the KeepAlive notifications
for the single subscription identified by the given unique 
clientSubscriptionHandle.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.registerLoggingCallback">
<code class="descname">registerLoggingCallback</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.registerLoggingCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback function to receive all log messages.</p>
<p>If you register a callback function, this callback function will be called instead of 
the <a class="reference internal" href="#pyuaf.client.Client.logMessageReceived" title="pyuaf.client.Client.logMessageReceived"><code class="xref py py-meth docutils literal"><span class="pre">logMessageReceived()</span></code></a> function (so the latter function will 
NOT be called anymore!).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>callback</strong> &#8211; A callback function for the logging. This function should have one 
input argument, which you should call &#8220;msg&#8221; or so,
because this argument is of type <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.LogMessage" title="pyuaf.util.LogMessage"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.util.LogMessage</span></code></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.registerNotificationsMissingCallback">
<code class="descname">registerNotificationsMissingCallback</code><span class="sig-paren">(</span><em>callback</em>, <em>onlyClientSubscriptionHandle=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.registerNotificationsMissingCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback to handle missing notifications.</p>
<p>You can register multiple callbacks: all of them will be called.
The <a class="reference internal" href="#pyuaf.client.Client.notificationsMissing" title="pyuaf.client.Client.notificationsMissing"><code class="xref py py-meth docutils literal"><span class="pre">pyuaf.client.Client.notificationsMissing()</span></code></a> method (which you may override) 
will also always be called, regardless of the callbacks you register.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>callback</strong> &#8211; <p>A callback function. This function should have three input 
arguments:</p>
<blockquote>
<div><ul>
<li>first argument will be a <a class="reference internal" href="#pyuaf.client.SessionInformation" title="pyuaf.client.SessionInformation"><code class="xref py py-class docutils literal"><span class="pre">SessionInformation</span></code></a> 
instance, describing the subscription that has missing 
notifications.</li>
<li>second argument will be an <code class="docutils literal"><span class="pre">int</span></code> representing the 
sequence number of the last notification just before 
notifications went missing.</li>
<li>third argument will be an <code class="docutils literal"><span class="pre">int</span></code> representing the 
sequence number of the first notification just after 
notifications went missing.</li>
</ul>
</div></blockquote>
</li>
<li><strong>onlyClientSubscriptionHandle</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; Optional argument: provide this argument if you don&#8217;t 
want to listen to the missing notifications of <em>all</em> 
subscriptions, but only listen to the missing notifications
for the single subscription identified by the given unique 
clientSubscriptionHandle.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.registerSubscriptionStatusCallback">
<code class="descname">registerSubscriptionStatusCallback</code><span class="sig-paren">(</span><em>callback</em>, <em>onlyClientSubscriptionHandle=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.registerSubscriptionStatusCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback to receive connection status changes.</p>
<p>You can register multiple callbacks: all of them will be called.
The <a class="reference internal" href="#pyuaf.client.Client.subscriptionStatusChanged" title="pyuaf.client.Client.subscriptionStatusChanged"><code class="xref py py-meth docutils literal"><span class="pre">pyuaf.client.Client.subscriptionStatusChanged()</span></code></a> method (which you may override) 
will also always be called, regardless of the callbacks you register.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>callback</strong> &#8211; A callback function. This function should have one input 
argument, to which the changed <a class="reference internal" href="#pyuaf.client.SessionInformation" title="pyuaf.client.SessionInformation"><code class="xref py py-class docutils literal"><span class="pre">SessionInformation</span></code></a> 
instance will be passed.</li>
<li><strong>onlyClientSubscriptionHandle</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; Optional argument: provide this argument if you don&#8217;t 
want to listen to the status changes of <em>all</em> subscriptions,
but only listen to the subscription changes for the single 
subscription identified by the given unique 
clientSubscriptionHandle.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.registerUntrustedServerCertificateCallback">
<code class="descname">registerUntrustedServerCertificateCallback</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.registerUntrustedServerCertificateCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback function to handle untrusted certificates during the connection process.</p>
<p>If you register a callback function, this callback function will be called instead of 
the <a class="reference internal" href="#pyuaf.client.Client.untrustedServerCertificateReceived" title="pyuaf.client.Client.untrustedServerCertificateReceived"><code class="xref py py-meth docutils literal"><span class="pre">untrustedServerCertificateReceived()</span></code></a> function 
(so the latter function will NOT be called anymore!).</p>
<p>The callback function should have:</p>
<ul class="simple">
<li>2 input arguments: &#8216;certificate&#8217; and &#8216;cause&#8217;</li>
<li>1 returned value: either <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_Reject" title="pyuaf.util.PkiCertificate.Action_Reject"><code class="xref py py-attr docutils literal"><span class="pre">Action_Reject</span></code></a> 
or <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_AcceptTemporarily" title="pyuaf.util.PkiCertificate.Action_AcceptTemporarily"><code class="xref py py-attr docutils literal"><span class="pre">Action_AcceptTemporarily</span></code></a> 
or <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_AcceptPermanently" title="pyuaf.util.PkiCertificate.Action_AcceptPermanently"><code class="xref py py-attr docutils literal"><span class="pre">Action_AcceptPermanently</span></code></a>.</li>
</ul>
<p>The signature of this method (and the meaning of these input arguments and returned value)
is exactly the same as <a class="reference internal" href="#pyuaf.client.Client.untrustedServerCertificateReceived" title="pyuaf.client.Client.untrustedServerCertificateReceived"><code class="xref py py-meth docutils literal"><span class="pre">untrustedServerCertificateReceived()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>callback</strong> &#8211; A callback function for handling untrusted certificates.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.serversFound">
<code class="descname">serversFound</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.serversFound" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of the application descriptions of the servers found in the discovery process.</p>
<p>The discovery is periodically being run in the background, so the returned list may 
change. The cycle time is of the discovery is configurable
via the <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ClientSettings" title="pyuaf.client.settings.ClientSettings"><code class="xref py py-class docutils literal"><span class="pre">ClientSettings</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the application descriptions that were found.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.ApplicationDescription" title="pyuaf.util.ApplicationDescription"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.util.ApplicationDescription</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.sessionInformation">
<code class="descname">sessionInformation</code><span class="sig-paren">(</span><em>clientConnectionId</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.sessionInformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Get information about the specified session.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>clientConnectionId</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The client connection id 
(always assigned by the UAF, not by the user!).</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Information about the specified session.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#pyuaf.client.SessionInformation" title="pyuaf.client.SessionInformation"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.SessionInformation</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.InvalidRequestError" title="pyuaf.util.errors.InvalidRequestError"><strong>pyuaf.util.errors.InvalidRequestError</strong></a> &#8211; Raised in case no session is known for the given client connection id.</li>
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any other errors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.setClientSettings">
<code class="descname">setClientSettings</code><span class="sig-paren">(</span><em>settings</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.setClientSettings" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the client settings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>settings</strong> (<a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ClientSettings" title="pyuaf.client.settings.ClientSettings"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.settings.ClientSettings</span></code></a>) &#8211; The new settings.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.setMonitoringMode">
<code class="descname">setMonitoringMode</code><span class="sig-paren">(</span><em>clientHandles</em>, <em>monitoringMode</em>, <em>serviceSettings=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.setMonitoringMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the monitoring mode for the specified monitored items.</p>
<p>This is the preferred way to temporarily stop receiving notifications for certain monitored
items (e.g. because a tab in a User Interface is not visible). See the example below.</p>
<p>Note that clientHandles instead of MonitoredItemIds are used to identify a monitored item. 
ClientHandles are assigned by the client and are therefore <em>static</em>, while MonitoredItemIds
are assigned by the server, so they may change over time (e.g. after restarting the server,
of after failover to a redundant server). The UAF will keep track of the mapping between 
both. This means that your monitored items are always identified in the same way (by their
clientHandles), no matter what happens on the server-side. The UAF takes care of the 
conversion automatically, so you don&#8217;t have to worry about it.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyuaf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyuaf.util.errors</span> <span class="k">import</span> <span class="n">UafError</span><span class="p">,</span> <span class="n">CreateMonitoredItemsError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyuaf.util</span> <span class="k">import</span> <span class="n">Address</span><span class="p">,</span> <span class="n">NodeId</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyuaf.client</span> <span class="k">import</span> <span class="n">Client</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyuaf.util</span> <span class="k">import</span> <span class="n">monitoringmodes</span> 
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myClient</span>     <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s2">&quot;myClient&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;opc.tcp://localhost:4841&quot;</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nameSpaceUri</span> <span class="o">=</span> <span class="s2">&quot;http://mycompany.com/mymachine&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">serverUri</span>    <span class="o">=</span> <span class="s2">&quot;http://mycompany.com/servers/plc1&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temperature</span>  <span class="o">=</span> <span class="n">Address</span><span class="p">(</span> <span class="n">NodeId</span><span class="p">(</span><span class="s2">&quot;myMachine.temperature&quot;</span><span class="p">,</span> <span class="n">nameSpaceUri</span><span class="p">),</span> <span class="n">serverUri</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pressure</span>     <span class="o">=</span> <span class="n">Address</span><span class="p">(</span> <span class="n">NodeId</span><span class="p">(</span><span class="s2">&quot;myMachine.pressure&quot;</span><span class="p">,</span> <span class="n">nameSpaceUri</span><span class="p">),</span> <span class="n">serverUri</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">updateTemperatureWidget</span><span class="p">(</span><span class="n">notification</span><span class="p">):</span>
<span class="gp">... </span>     <span class="n">temperatureIndicator</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.1f</span><span class="s2"> K&quot;</span> <span class="o">%</span><span class="n">notification</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">updatePressureWidget</span><span class="p">(</span><span class="n">notification</span><span class="p">):</span>
<span class="gp">... </span>     <span class="n">pressureIndicator</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.1f</span><span class="s2"> Bar&quot;</span> <span class="o">%</span><span class="n">notification</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">myClient</span><span class="o">.</span><span class="n">createMonitoredData</span><span class="p">(</span>
<span class="gp">... </span>                <span class="n">addresses</span> <span class="o">=</span> <span class="p">[</span><span class="n">temperature</span><span class="p">,</span> <span class="n">pressure</span><span class="p">],</span> 
<span class="gp">... </span>                <span class="n">notificationCallbacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">updateTemperatureWidget</span><span class="p">,</span> <span class="n">updatePressureWidget</span><span class="p">])</span>
<span class="gp">... </span>    <span class="c1"># store the clientHandles:</span>
<span class="gp">... </span>    <span class="n">clientHandles</span> <span class="o">=</span> <span class="p">[</span> <span class="n">target</span><span class="o">.</span><span class="n">clientHandle</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">targets</span> <span class="p">]</span>
<span class="gp">... </span><span class="k">except</span> <span class="n">CreateMonitoredItemsError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="c1"># The monitored items could not be created, because there was some failure</span>
<span class="gp">... </span>    <span class="c1">#  (maybe the server is off-line?).</span>
<span class="gp">... </span>    <span class="c1"># Nevertheless, the client handles were already assigned, and we can get them like this: </span>
<span class="gp">... </span>    <span class="n">clientHandle</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">assignedClientHandles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span><span class="k">except</span> <span class="n">UafError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Oops, an unexpected error!&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">uiTabChangedState</span><span class="p">(</span><span class="n">visible</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">visible</span><span class="p">:</span>
<span class="gp">... </span>         <span class="n">monitoringMode</span> <span class="o">=</span> <span class="n">monitoringmodes</span><span class="o">.</span><span class="n">Sampling</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>         <span class="n">monitoringMode</span> <span class="o">=</span> <span class="n">monitoringmodes</span><span class="o">.</span><span class="n">Reporting</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">statuses</span> <span class="o">=</span> <span class="n">myClient</span><span class="o">.</span><span class="n">setMonitoringMode</span><span class="p">(</span><span class="n">clientHandles</span><span class="p">,</span> <span class="n">monitoringMode</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">statuses</span><span class="p">)):</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">statuses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isGood</span><span class="p">():</span>
<span class="gp">... </span>                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Could not set monitoring mode of widget </span><span class="si">%d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">statuses</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> 
<span class="gp">... </span>    <span class="k">except</span> <span class="n">UafError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t set the new monitoring mode: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clientHandles</strong> (<code class="docutils literal"><span class="pre">list</span></code> of <code class="docutils literal"><span class="pre">int</span></code>) &#8211; List of client handles of the monitored items you want to change.</li>
<li><strong>monitoringMode</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; New monitoring mode, as defined in <a class="reference internal" href="api_pyuaf_util_monitoringmodes.html#module-pyuaf.util.monitoringmodes" title="pyuaf.util.monitoringmodes"><code class="xref py py-mod docutils literal"><span class="pre">pyuaf.util.monitoringmodes</span></code></a>.</li>
<li><strong>serviceSettings</strong> (<a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ServiceSettings" title="pyuaf.client.settings.ServiceSettings"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.settings.ServiceSettings</span></code></a>) &#8211; The service settings to be used (leave None for default settings).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of statuses, one for each client handle.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.StatusVector" title="pyuaf.util.StatusVector"><code class="xref py py-class docutils literal"><span class="pre">StatusVector</span></code></a>.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.setPublishingMode">
<code class="descname">setPublishingMode</code><span class="sig-paren">(</span><em>clientSubscriptionHandle</em>, <em>publishingEnabled</em>, <em>serviceSettings=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.setPublishingMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the publishing mode, by specifying a subscription handle.</p>
<p>Note that a subscription handle may <em>not</em> be known at the time when you create the
monitored items. E.g. when you call <a class="reference internal" href="#pyuaf.client.Client.createMonitoredData" title="pyuaf.client.Client.createMonitoredData"><code class="xref py py-meth docutils literal"><span class="pre">createMonitoredData()</span></code></a> or 
<a class="reference internal" href="#pyuaf.client.Client.createMonitoredEvents" title="pyuaf.client.Client.createMonitoredEvents"><code class="xref py py-meth docutils literal"><span class="pre">createMonitoredEvents()</span></code></a>, it can happen that the server that 
hosts the monitored items is not on-line yet. In this case, the ClientSubscriptionHandle 
is <em>not</em> assigned yet, but ClientHandles <em>are</em> assigned yet. Therefore it makes sense to 
first call <a class="reference internal" href="#pyuaf.client.Client.monitoredItemInformation" title="pyuaf.client.Client.monitoredItemInformation"><code class="xref py py-meth docutils literal"><span class="pre">monitoredItemInformation()</span></code></a> of your monitored item, 
and get the subscription handle from there.</p>
<p>E.g. like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyuaf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyuaf.util.errors</span> <span class="k">import</span> <span class="n">UafError</span><span class="p">,</span> <span class="n">CreateMonitoredItemsError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyuaf.util</span> <span class="k">import</span> <span class="n">Address</span><span class="p">,</span> <span class="n">NodeId</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyuaf.client</span> <span class="k">import</span> <span class="n">Client</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myClient</span>     <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s2">&quot;myClient&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;opc.tcp://localhost:4841&quot;</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nameSpaceUri</span> <span class="o">=</span> <span class="s2">&quot;http://mycompany.com/mymachine&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">serverUri</span>    <span class="o">=</span> <span class="s2">&quot;http://mycompany.com/servers/plc1&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span> <span class="n">NodeId</span><span class="p">(</span><span class="s2">&quot;myMachine.myVariable&quot;</span><span class="p">,</span> <span class="n">nameSpaceUri</span><span class="p">),</span> <span class="n">serverUri</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">myCallback</span><span class="p">(</span><span class="n">notification</span><span class="p">):</span>
<span class="gp">... </span>     <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A data change was received: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">notification</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">myClient</span><span class="o">.</span><span class="n">createMonitoredData</span><span class="p">([</span><span class="n">address</span><span class="p">],</span> 
<span class="gp">... </span>                                          <span class="n">notificationCallbacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">myCallback</span><span class="p">])</span>
<span class="gp">... </span>    <span class="n">clientHandle</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clientHandle</span>
<span class="gp">... </span><span class="k">except</span> <span class="n">CreateMonitoredItemsError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="c1"># The monitored items could not be created, because there was some failure</span>
<span class="gp">... </span>    <span class="c1">#  (maybe the server is off-line?).</span>
<span class="gp">... </span>    <span class="c1"># Nevertheless, the client handles were already assigned, and we can get them like this: </span>
<span class="gp">... </span>    <span class="n">clientHandle</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">assignedClientHandles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span><span class="k">except</span> <span class="n">UafError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Oops, an unexpected error!&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">info</span> <span class="o">=</span> <span class="n">myClient</span><span class="o">.</span><span class="n">monitoredItemInformation</span><span class="p">(</span><span class="n">clientHandle</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">monitoredItemState</span> <span class="o">==</span> <span class="n">pyuaf</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">monitoreditemstates</span><span class="o">.</span><span class="n">Created</span><span class="p">:</span>
<span class="gp">... </span>    <span class="c1"># enable the subscription that hosts the monitored item:</span>
<span class="gp">... </span>    <span class="n">myClient</span><span class="o">.</span><span class="n">setPublishingMode</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">clientSubscriptionHandle</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>        
<span class="gp">... </span>    <span class="c1"># ... do some stuff ...</span>
<span class="gp">... </span>        
<span class="gp">... </span>    <span class="c1"># disable the subscription that hosts the monitored item:</span>
<span class="gp">... </span>    <span class="n">myClient</span><span class="o">.</span><span class="n">setPublishingMode</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">clientSubscriptionHandle</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clientSubscriptionHandle</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The handle identifying the subscription.</li>
<li><strong>publishingEnabled</strong> (<code class="docutils literal"><span class="pre">bool</span></code>) &#8211; True to enable the publishing mode, false to disable.</li>
<li><strong>serviceSettings</strong> (<a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ServiceSettings" title="pyuaf.client.settings.ServiceSettings"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.settings.ServiceSettings</span></code></a>) &#8211; The service settings to be used (leave None for 
default settings).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UnknownClientHandleError" title="pyuaf.util.errors.UnknownClientHandleError"><strong>pyuaf.util.errors.UnknownClientHandleError</strong></a> &#8211; The clientSubscriptionHandle is unknown!</li>
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.structureDefinition">
<code class="descname">structureDefinition</code><span class="sig-paren">(</span><em>dataTypeId</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.structureDefinition" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a structure definition for the given datatype NodeId.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataTypeId</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.NodeId" title="pyuaf.util.NodeId"><code class="xref py py-class docutils literal"><span class="pre">NodeId</span></code></a>.) &#8211; NodeId of the datatype.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The definition of this datatype.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.StructureDefinition" title="pyuaf.util.StructureDefinition"><code class="xref py py-class docutils literal"><span class="pre">StructureDefinition</span></code></a>.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.DefinitionNotFoundError" title="pyuaf.util.errors.DefinitionNotFoundError"><strong>pyuaf.util.errors.DefinitionNotFoundError</strong></a> &#8211; Will be raised if no definition could be found.</li>
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.subscriptionInformation">
<code class="descname">subscriptionInformation</code><span class="sig-paren">(</span><em>clientSubscriptionHandle</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.subscriptionInformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Get information about the specified subscription.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>clientSubscriptionHandle</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The client subscription handle 
(always assigned by the UAF, not by the user!).</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Information about the specified subscription.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#pyuaf.client.SubscriptionInformation" title="pyuaf.client.SubscriptionInformation"><code class="xref py py-class docutils literal"><span class="pre">SubscriptionInformation</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.InvalidRequestError" title="pyuaf.util.errors.InvalidRequestError"><strong>pyuaf.util.errors.InvalidRequestError</strong></a> &#8211; Raised in case no subscription is known for the given client subscription handle.</li>
<li><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any other errors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.subscriptionStatusChanged">
<code class="descname">subscriptionStatusChanged</code><span class="sig-paren">(</span><em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.subscriptionStatusChanged" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method to receive subscription status changes.</p>
<p>Alternatively, you can also register callback functions which you defined yourself, by
registering them using <a class="reference internal" href="#pyuaf.client.Client.registerSubscriptionStatusCallback" title="pyuaf.client.Client.registerSubscriptionStatusCallback"><code class="xref py py-meth docutils literal"><span class="pre">pyuaf.client.Client.registerSubscriptionStatusCallback()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>info</strong> (<a class="reference internal" href="#pyuaf.client.SubscriptionInformation" title="pyuaf.client.SubscriptionInformation"><code class="xref py py-class docutils literal"><span class="pre">SubscriptionInformation</span></code></a>) &#8211; Updated subscription information.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.unregisterConnectErrorCallback">
<code class="descname">unregisterConnectErrorCallback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.unregisterConnectErrorCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a callback function to stop handling connect errors.</p>
<p>If you unregister a callback function, the connect error will be send to 
<a class="reference internal" href="#pyuaf.client.Client.connectErrorReceived" title="pyuaf.client.Client.connectErrorReceived"><code class="xref py py-meth docutils literal"><span class="pre">connectErrorReceived()</span></code></a> instead.</p>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.unregisterLoggingCallback">
<code class="descname">unregisterLoggingCallback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.unregisterLoggingCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a callback function to stop receiving all log messages.</p>
<p>If you unregister a callback function, and callback logging is still enabled (via the 
client settings), the log messages will be sent to the :meth:logMessageReceived method 
(so you can virtually override this method to receive the log messages).</p>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.unregisterUntrustedServerCertificateCallback">
<code class="descname">unregisterUntrustedServerCertificateCallback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.unregisterUntrustedServerCertificateCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a callback function to stop handling untrusted certificates.</p>
<p>If you unregister a callback function, the untrusted certificates will be send to 
<a class="reference internal" href="#pyuaf.client.Client.untrustedServerCertificateReceived" title="pyuaf.client.Client.untrustedServerCertificateReceived"><code class="xref py py-meth docutils literal"><span class="pre">untrustedServerCertificateReceived()</span></code></a> instead
(so you can override this method to receive the certificates).</p>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.untrustedServerCertificateReceived">
<code class="descname">untrustedServerCertificateReceived</code><span class="sig-paren">(</span><em>certificate</em>, <em>cause</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.untrustedServerCertificateReceived" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method if you want to handle an untrusted certificate.</p>
<p>This method is called by the UAF whenever an untrusted (e.g. unknown) server certificate 
must be checked at the application level (as part of the connection step, before a 
communication channel is established). Note that this has nothing to do with signed or
encrypted communication! Even if you don&#8217;t want to connect to a secured endpoint,
you&#8217;re advised to verify the certificate of the server to make sure you&#8217;re talking to 
the right one.</p>
<p>It will <strong>not</strong> be called however when you registered a callback function via 
<a class="reference internal" href="#pyuaf.client.Client.registerUntrustedServerCertificateCallback" title="pyuaf.client.Client.registerUntrustedServerCertificateCallback"><code class="xref py py-meth docutils literal"><span class="pre">registerUntrustedServerCertificateCallback()</span></code></a>.
So you must choose how to handle untrusted server certificates:
- either by overriding <a class="reference internal" href="#pyuaf.client.Client.untrustedServerCertificateReceived" title="pyuaf.client.Client.untrustedServerCertificateReceived"><code class="xref py py-meth docutils literal"><span class="pre">untrustedServerCertificateReceived()</span></code></a>
- or by registering a callback via  <a class="reference internal" href="#pyuaf.client.Client.registerUntrustedServerCertificateCallback" title="pyuaf.client.Client.registerUntrustedServerCertificateCallback"><code class="xref py py-meth docutils literal"><span class="pre">registerUntrustedServerCertificateCallback()</span></code></a>.</p>
<p>This method will be called by the UAF, so you must override it. It is called by
the UAF whenever it thinks that it should verify the certificate of the server 
(i.e. during (re)connection).</p>
<p>Typically, during the first connection to a server, the certificate of the server is 
not known to the client yet. By overriding this method, you can therefore show the 
certificate to the user of your software, and ask him/her whether or not
he/she thinks the certificate can be trusted.</p>
<p>Three options are available:</p>
<ul class="simple">
<li><a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_Reject" title="pyuaf.util.PkiCertificate.Action_Reject"><code class="xref py py-attr docutils literal"><span class="pre">Action_Reject</span></code></a>: don&#8217;t trust the certificate, and 
therefore don&#8217;t try to connect.</li>
<li><a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_AcceptTemporarily" title="pyuaf.util.PkiCertificate.Action_AcceptTemporarily"><code class="xref py py-attr docutils literal"><span class="pre">Action_AcceptTemporarily</span></code></a>: trust the certificate
temporarily, i.e. don&#8217;t store it in the trust list but just -for now- allow connection
to the server. If the UAF must reconnect at some point to the server and the server 
certificate must be checked again, the user shall again have to confirm the certificate.</li>
<li><a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_AcceptPermanently" title="pyuaf.util.PkiCertificate.Action_AcceptPermanently"><code class="xref py py-attr docutils literal"><span class="pre">Action_AcceptPermanently</span></code></a>: store the certificate 
in the trust list (as defined by the 
<a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.ClientSettings.certificateTrustListLocation" title="pyuaf.client.settings.ClientSettings.certificateTrustListLocation"><code class="xref py py-attr docutils literal"><span class="pre">certificateTrustListLocation</span></code></a>: setting) and 
accept the connection. Since the certificate is stored on disk in the trust list,
the client application will automatically trust the certificate in the future (until
the certificate expires, of course).</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>You must <strong>always</strong> return one of the following integers:</p>
<ul class="last simple">
<li><a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_Reject" title="pyuaf.util.PkiCertificate.Action_Reject"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.PkiCertificate.Action_Reject</span></code></a></li>
<li><a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_AcceptTemporarily" title="pyuaf.util.PkiCertificate.Action_AcceptTemporarily"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.PkiCertificate.Action_AcceptTemporarily</span></code></a></li>
<li><a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_AcceptPermanently" title="pyuaf.util.PkiCertificate.Action_AcceptPermanently"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.PkiCertificate.Action_AcceptPermanently</span></code></a></li>
</ul>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">By default, <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_AcceptTemporarily" title="pyuaf.util.PkiCertificate.Action_AcceptTemporarily"><code class="xref py py-attr docutils literal"><span class="pre">Action_AcceptTemporarily</span></code></a> is returned, 
which means that all untrusted certificates will be <strong>accepted</strong> by default!
Admittingly that doesn&#8217;t sound very safe, but it simply implies that by default
a pyuaf Client will be able to connect to any (unknown) server without needing to 
override this method. If you don&#8217;t trust the servers in your network, you should 
override this method.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Check out example &#8220;how_to_connect_to_a_secured_endpoint.py&#8221; for more information.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>certificate</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate" title="pyuaf.util.PkiCertificate"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.util.PkiCertificate</span></code></a>) &#8211; The untrusted certificate.</li>
<li><strong>cause</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Status" title="pyuaf.util.Status"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.util.Status</span></code></a>) &#8211; The reason why it was untrusted 
(mostly because it is simply not found in the trust list, but it may also
be that it&#8217;s not trusted because e.g. the trust list could not be opened).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">either 
<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_Reject" title="pyuaf.util.PkiCertificate.Action_Reject"><code class="xref py py-attr docutils literal"><span class="pre">Action_Reject</span></code></a> or 
<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_AcceptTemporarily" title="pyuaf.util.PkiCertificate.Action_AcceptTemporarily"><code class="xref py py-attr docutils literal"><span class="pre">Action_AcceptTemporarily</span></code></a> or 
<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.PkiCertificate.Action_AcceptPermanently" title="pyuaf.util.PkiCertificate.Action_AcceptPermanently"><code class="xref py py-attr docutils literal"><span class="pre">Action_AcceptPermanently</span></code></a>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal"><span class="pre">int</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>addresses</em>, <em>data</em>, <em>attributeId=13</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a number of node attributes synchronously.</p>
<p>This is a convenience function for calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-class docutils literal"><span class="pre">processRequest</span></code></a> with 
a <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.WriteRequest" title="pyuaf.client.requests.WriteRequest"><code class="xref py py-class docutils literal"><span class="pre">WriteRequest</span></code></a> as its first argument.
For full flexibility, use that function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addresses</strong> (<a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a> or a <code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Address" title="pyuaf.util.Address"><code class="xref py py-class docutils literal"><span class="pre">Address</span></code></a>) &#8211; A single address or a list of addresses of nodes of which the specified 
attribute should be written.</li>
<li><strong>data</strong> (<a class="reference internal" href="api_pyuaf_util_primitives.html#pyuaf.util.primitives.UInt32" title="pyuaf.util.primitives.UInt32"><code class="xref py py-class docutils literal"><span class="pre">UInt32</span></code></a> or <code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="api_pyuaf_util_primitives.html#pyuaf.util.primitives.UInt32" title="pyuaf.util.primitives.UInt32"><code class="xref py py-class docutils literal"><span class="pre">UInt32</span></code></a>
or any other data type of the supported dynamic data types (or a <code class="docutils literal"><span class="pre">list</span></code> of them).) &#8211; A single value or a list of values to be written.</li>
<li><strong>attributeId</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; The id of the attribute to be written (e.g. <a class="reference internal" href="api_pyuaf_util_attributeids.html#pyuaf.util.attributeids.Value" title="pyuaf.util.attributeids.Value"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.attributeids.Value</span></code></a>
or <a class="reference internal" href="api_pyuaf_util_attributeids.html#pyuaf.util.attributeids.DisplayName" title="pyuaf.util.attributeids.DisplayName"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.util.attributeids.DisplayName</span></code></a>) for all addresses.</li>
<li><strong>kwargs</strong> &#8211; <p>The following **kwargs are available (see <a class="reference internal" href="api_client_kwargs.html#note-client-kwargs"><span class="std std-ref">A note on **kwargs for Client services</span></a>):</p>
<ul>
<li>clientConnectionId: (type: <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>sessionSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>)</li>
<li>serviceSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.WriteSettings" title="pyuaf.client.settings.WriteSettings"><code class="xref py py-class docutils literal"><span class="pre">WriteSettings</span></code></a>)</li>
<li>translateSettings (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings" title="pyuaf.client.settings.TranslateBrowsePathsToNodeIdsSettings"><code class="xref py py-class docutils literal"><span class="pre">TranslateBrowsePathsToNodeIdsSettings</span></code></a>)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result of the write request.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.WriteResult" title="pyuaf.client.results.WriteResult"><code class="xref py py-class docutils literal"><span class="pre">WriteResult</span></code></a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="api_pyuaf_util_errors.html#pyuaf.util.errors.UafError" title="pyuaf.util.errors.UafError"><strong>pyuaf.util.errors.UafError</strong></a> &#8211; Base exception, catch this to handle any UAF errors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.Client.writeComplete">
<code class="descname">writeComplete</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.Client.writeComplete" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method to catch the result of asynchronous write requests.</p>
<p>This method will only be called by the UAF if you didn&#8217;t provide an &#8220;external&#8221; callback
function already when you began the asynchronous write request.</p>
<p>In other words, there are two ways how you can catch the result of asynchronous write requests:</p>
<blockquote>
<div><ul class="simple">
<li>either by calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-meth docutils literal"><span class="pre">processRequest()</span></code></a> or <cite>:meth:~pyuaf.client.Client.beginWrite</cite> 
<em>without</em> providing an external callback function &#8211;&gt; then you need to override 
<a class="reference internal" href="#pyuaf.client.Client.writeComplete" title="pyuaf.client.Client.writeComplete"><code class="xref py py-meth docutils literal"><span class="pre">writeComplete()</span></code></a></li>
<li>or by calling <a class="reference internal" href="#pyuaf.client.Client.processRequest" title="pyuaf.client.Client.processRequest"><code class="xref py py-meth docutils literal"><span class="pre">processRequest()</span></code></a> <em>with</em> providing an external 
callback function &#8211;&gt; then only the external callback function will be called.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>result</strong> (<a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.WriteResult" title="pyuaf.client.results.WriteResult"><code class="xref py py-class docutils literal"><span class="pre">WriteResult</span></code></a>) &#8211; The asynchronously received write result.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-monitorediteminformation">
<h2><em>class</em> MonitoredItemInformation<a class="headerlink" href="#class-monitorediteminformation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyuaf.client.MonitoredItemInformation">
<em class="property">class </em><code class="descclassname">pyuaf.client.</code><code class="descname">MonitoredItemInformation</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.MonitoredItemInformation" title="Permalink to this definition">¶</a></dt>
<dd><p>A MonitoredItemInformation object contains information about a monitored item.</p>
<ul>
<li><p class="first">Methods:</p>
<blockquote>
<div><dl class="method">
<dt id="pyuaf.client.MonitoredItemInformation.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.MonitoredItemInformation.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a new MonitoredItemInformation object.</p>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.MonitoredItemInformation.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.MonitoredItemInformation.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a string representation.</p>
</dd></dl>

</div></blockquote>
</li>
<li><p class="first">Attributes:</p>
<blockquote>
<div><dl class="attribute">
<dt id="pyuaf.client.MonitoredItemInformation.monitoredItemState">
<code class="descname">monitoredItemState</code><a class="headerlink" href="#pyuaf.client.MonitoredItemInformation.monitoredItemState" title="Permalink to this definition">¶</a></dt>
<dd><p>An <code class="docutils literal"><span class="pre">int</span></code> representing the state of the monitored item
(e.g. <a class="reference internal" href="api_pyuaf_client_monitoreditemstates.html#pyuaf.client.monitoreditemstates.Created" title="pyuaf.client.monitoreditemstates.Created"><code class="xref py py-attr docutils literal"><span class="pre">Created</span></code></a>).</p>
<p>The possible states are defined in the <a class="reference internal" href="api_pyuaf_client_monitoreditemstates.html#module-pyuaf.client.monitoreditemstates" title="pyuaf.client.monitoreditemstates"><code class="xref py py-mod docutils literal"><span class="pre">pyuaf.client.monitoreditemstates</span></code></a> module.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.MonitoredItemInformation.clientConnectionId">
<code class="descname">clientConnectionId</code><a class="headerlink" href="#pyuaf.client.MonitoredItemInformation.clientConnectionId" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the session that hosts the subscription (which in turn hosts the monitored
item), as a <code class="docutils literal"><span class="pre">long</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.MonitoredItemInformation.clientSubscriptionHandle">
<code class="descname">clientSubscriptionHandle</code><a class="headerlink" href="#pyuaf.client.MonitoredItemInformation.clientSubscriptionHandle" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle of the subscription that hosts the monitored item, as a <code class="docutils literal"><span class="pre">long</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.MonitoredItemInformation.clientHandle">
<code class="descname">clientHandle</code><a class="headerlink" href="#pyuaf.client.MonitoredItemInformation.clientHandle" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle of the monitored item, as a <code class="docutils literal"><span class="pre">long</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.MonitoredItemInformation.settings">
<code class="descname">settings</code><a class="headerlink" href="#pyuaf.client.MonitoredItemInformation.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>The settings of this particular monitored item, as an instance of type
<a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.MonitoredItemSettings" title="pyuaf.client.settings.MonitoredItemSettings"><code class="xref py py-class docutils literal"><span class="pre">MonitoredItemSettings</span></code></a>.</p>
</dd></dl>

</div></blockquote>
</li>
</ul>
</dd></dl>

</div>
<div class="section" id="class-monitoreditemnotification">
<h2><em>class</em> MonitoredItemNotification<a class="headerlink" href="#class-monitoreditemnotification" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyuaf.client.MonitoredItemNotification">
<em class="property">class </em><code class="descclassname">pyuaf.client.</code><code class="descname">MonitoredItemNotification</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.MonitoredItemNotification" title="Permalink to this definition">¶</a></dt>
<dd><p>A MonitoredItemNotification is the common superclass class of
<a class="reference internal" href="#pyuaf.client.DataChangeNotification" title="pyuaf.client.DataChangeNotification"><code class="xref py py-class docutils literal"><span class="pre">DataChangeNotification</span></code></a> and <a class="reference internal" href="#pyuaf.client.EventNotification" title="pyuaf.client.EventNotification"><code class="xref py py-class docutils literal"><span class="pre">EventNotification</span></code></a>.</p>
<ul>
<li><p class="first">Methods:</p>
<blockquote>
<div><dl class="method">
<dt id="pyuaf.client.MonitoredItemNotification.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.MonitoredItemNotification.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a new MonitoredItemNotification.</p>
<dl class="docutils">
<dt>You&#8217;ll never need to create notifications like this yourself because:</dt>
<dd><ul class="first last simple">
<li>only the subclasses <a class="reference internal" href="#pyuaf.client.DataChangeNotification" title="pyuaf.client.DataChangeNotification"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.DataChangeNotification</span></code></a> and
<a class="reference internal" href="#pyuaf.client.EventNotification" title="pyuaf.client.EventNotification"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.EventNotification</span></code></a> will be instantiated, never the
superclass itself</li>
<li>the UAF will produce notifications and provide them to you, so you can consume them.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.MonitoredItemNotification.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.MonitoredItemNotification.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a string representation.</p>
</dd></dl>

</div></blockquote>
</li>
<li><p class="first">Attributes:</p>
<blockquote>
<div><dl class="attribute">
<dt id="pyuaf.client.MonitoredItemNotification.clientHandle">
<code class="descname">clientHandle</code><a class="headerlink" href="#pyuaf.client.MonitoredItemNotification.clientHandle" title="Permalink to this definition">¶</a></dt>
<dd><p>A clientHandle is a 32-bit number assigned by the UAF to newly created
monitored items. Essentially, it allows you to identify the monitored item of which
you receive this notification.</p>
<p>You can store the client handle when you created the monitored item, see for
example the use case example at <a class="reference internal" href="api_pyuaf_client_results.html#pyuaf.client.results.CreateMonitoredDataResultTarget.clientHandle" title="pyuaf.client.results.CreateMonitoredDataResultTarget.clientHandle"><code class="xref py py-meth docutils literal"><span class="pre">pyuaf.client.results.CreateMonitoredDataResultTarget.clientHandle()</span></code></a>.</p>
<p>If you use &#8220;notification callbacks&#8221;, you don&#8217;t need to worry about client handles
(because the notifications will be automatically mapped to your callback functions
that implement behavior for a specific monitored item.</p>
</dd></dl>

</div></blockquote>
</li>
</ul>
</dd></dl>

</div>
<div class="section" id="class-datachangenotification">
<h2><em>class</em> DataChangeNotification<a class="headerlink" href="#class-datachangenotification" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyuaf.client.DataChangeNotification">
<em class="property">class </em><code class="descclassname">pyuaf.client.</code><code class="descname">DataChangeNotification</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.DataChangeNotification" title="Permalink to this definition">¶</a></dt>
<dd><p>A DataChangeNotification is a notification for a monitored data item.</p>
<ul>
<li><p class="first">Methods:</p>
<blockquote>
<div><dl class="method">
<dt id="pyuaf.client.DataChangeNotification.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.DataChangeNotification.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a new DataChangeNotification.</p>
<p>You&#8217;ll never need to create notifications like this yourself, because the UAF will
produce them and provide them to you, so you can consume them.</p>
</dd></dl>

</div></blockquote>
</li>
<li><p class="first">Attributes inherited from <a class="reference internal" href="#pyuaf.client.MonitoredItemNotification" title="pyuaf.client.MonitoredItemNotification"><code class="xref py py-class docutils literal"><span class="pre">MonitoredItemNotification</span></code></a>:</p>
<blockquote>
<div><dl class="attribute">
<dt id="pyuaf.client.DataChangeNotification.clientHandle">
<code class="descname">clientHandle</code><a class="headerlink" href="#pyuaf.client.DataChangeNotification.clientHandle" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8211;&gt; See <a class="reference internal" href="#pyuaf.client.MonitoredItemNotification.clientHandle" title="pyuaf.client.MonitoredItemNotification.clientHandle"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.client.MonitoredItemNotification.clientHandle</span></code></a>.</p>
</dd></dl>

</div></blockquote>
</li>
<li><p class="first">Other attributes:</p>
<blockquote>
<div><dl class="attribute">
<dt id="pyuaf.client.DataChangeNotification.status">
<code class="descname">status</code><a class="headerlink" href="#pyuaf.client.DataChangeNotification.status" title="Permalink to this definition">¶</a></dt>
<dd><p>The status of the data (a <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Status" title="pyuaf.util.Status"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.util.Status</span></code></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.DataChangeNotification.data">
<code class="descname">data</code><a class="headerlink" href="#pyuaf.client.DataChangeNotification.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The changed data.</p>
<p>The type of this data depends on the type of the variable you are monitoring.
This means that it has a dynamic data type.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="api_variants.html#note-variants"><span class="std std-ref">A note on dynamic data types</span></a>.</p>
</div>
</dd></dl>

</div></blockquote>
</li>
</ul>
</dd></dl>

</div>
<div class="section" id="class-eventnotification">
<h2><em>class</em> EventNotification<a class="headerlink" href="#class-eventnotification" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyuaf.client.EventNotification">
<em class="property">class </em><code class="descclassname">pyuaf.client.</code><code class="descname">EventNotification</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.EventNotification" title="Permalink to this definition">¶</a></dt>
<dd><p>An EventNotification is a notification for a monitored event item.</p>
<ul>
<li><p class="first">Methods:</p>
<blockquote>
<div><dl class="method">
<dt id="pyuaf.client.EventNotification.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.EventNotification.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a new EventNotification.</p>
<p>You&#8217;ll never need to create notifications like this yourself, because the UAF will
produce them and provide them to you, so you can consume them.</p>
</dd></dl>

</div></blockquote>
</li>
<li><p class="first">Attributes inherited from <a class="reference internal" href="#pyuaf.client.MonitoredItemNotification" title="pyuaf.client.MonitoredItemNotification"><code class="xref py py-class docutils literal"><span class="pre">MonitoredItemNotification</span></code></a>:</p>
<blockquote>
<div><dl class="attribute">
<dt id="pyuaf.client.EventNotification.clientHandle">
<code class="descname">clientHandle</code><a class="headerlink" href="#pyuaf.client.EventNotification.clientHandle" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8211;&gt; See <a class="reference internal" href="#pyuaf.client.MonitoredItemNotification.clientHandle" title="pyuaf.client.MonitoredItemNotification.clientHandle"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.client.MonitoredItemNotification.clientHandle</span></code></a>.</p>
</dd></dl>

</div></blockquote>
</li>
<li><p class="first">Other attributes:</p>
<blockquote>
<div><dl class="attribute">
<dt id="pyuaf.client.EventNotification.fields">
<code class="descname">fields</code><a class="headerlink" href="#pyuaf.client.EventNotification.fields" title="Permalink to this definition">¶</a></dt>
<dd><p>The values of the fields you are monitoring (in the same order as the select clauses which
you specified in the <a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.CreateMonitoredEventsRequestTarget" title="pyuaf.client.requests.CreateMonitoredEventsRequestTarget"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.requests.CreateMonitoredEventsRequestTarget</span></code></a>).</p>
<p>Since the type of the fields depend on the type of the select clauses of your
<a class="reference internal" href="api_pyuaf_client_requests.html#pyuaf.client.requests.CreateMonitoredEventsRequestTarget" title="pyuaf.client.requests.CreateMonitoredEventsRequestTarget"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.client.requests.CreateMonitoredEventsRequestTarget</span></code></a>, the fields are
presented to you as a <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.VariantVector" title="pyuaf.util.VariantVector"><code class="xref py py-class docutils literal"><span class="pre">pyuaf.util.VariantVector</span></code></a>.</p>
</dd></dl>

</div></blockquote>
</li>
</ul>
</dd></dl>

</div>
<div class="section" id="class-keepalivenotification">
<h2><em>class</em> KeepAliveNotification<a class="headerlink" href="#class-keepalivenotification" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyuaf.client.KeepAliveNotification">
<em class="property">class </em><code class="descclassname">pyuaf.client.</code><code class="descname">KeepAliveNotification</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.KeepAliveNotification" title="Permalink to this definition">¶</a></dt>
<dd><p>A KeepAliveNotification is sent by the server to notify the client that the subscription is
still alive.</p>
<p>It is sent when the data that is monitored by the client has not changed for a
while. E.g. suppose a client wants to monitor some data, and it specifies a
<a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SubscriptionSettings.publishingIntervalSec" title="pyuaf.client.settings.SubscriptionSettings.publishingIntervalSec"><code class="xref py py-attr docutils literal"><span class="pre">publishingIntervalSec</span></code></a> of 1.0 seconds
and a <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SubscriptionSettings.maxKeepAliveCount" title="pyuaf.client.settings.SubscriptionSettings.maxKeepAliveCount"><code class="xref py py-attr docutils literal"><span class="pre">maxKeepAliveCount</span></code></a> of 5.
As a result, when the monitored data changes rapidly, the client will be notified once per
second. But every time the monitored data remains constant for 1.0 * 5 = 5.0 seconds,
a KeepAliveNotification will be sent instead to notify the client that everything is still OK.</p>
<ul>
<li><p class="first">Methods:</p>
<blockquote>
<div><dl class="method">
<dt id="pyuaf.client.KeepAliveNotification.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.KeepAliveNotification.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a new KeepAliveNotification.</p>
<p>You&#8217;ll never need to create notifications like this yourself, because the UAF will
produce them and provide them to you, so you can consume them.</p>
</dd></dl>

</div></blockquote>
</li>
<li><p class="first">Attributes inherited from <a class="reference internal" href="#pyuaf.client.SubscriptionInformation" title="pyuaf.client.SubscriptionInformation"><code class="xref py py-class docutils literal"><span class="pre">SubscriptionInformation</span></code></a>:</p>
<blockquote>
<div><dl class="attribute">
<dt id="pyuaf.client.KeepAliveNotification.clientConnectionId">
<code class="descname">clientConnectionId</code><a class="headerlink" href="#pyuaf.client.KeepAliveNotification.clientConnectionId" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8211;&gt; See <a class="reference internal" href="#pyuaf.client.SubscriptionInformation.clientConnectionId" title="pyuaf.client.SubscriptionInformation.clientConnectionId"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.client.SubscriptionInformation.clientConnectionId</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.KeepAliveNotification.clientSubscriptionHandle">
<code class="descname">clientSubscriptionHandle</code><a class="headerlink" href="#pyuaf.client.KeepAliveNotification.clientSubscriptionHandle" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8211;&gt; See <a class="reference internal" href="#pyuaf.client.SubscriptionInformation.clientSubscriptionHandle" title="pyuaf.client.SubscriptionInformation.clientSubscriptionHandle"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.client.SubscriptionInformation.clientSubscriptionHandle</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.KeepAliveNotification.subscriptionState">
<code class="descname">subscriptionState</code><a class="headerlink" href="#pyuaf.client.KeepAliveNotification.subscriptionState" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8211;&gt; See <a class="reference internal" href="#pyuaf.client.SubscriptionInformation.subscriptionState" title="pyuaf.client.SubscriptionInformation.subscriptionState"><code class="xref py py-attr docutils literal"><span class="pre">pyuaf.client.SubscriptionInformation.subscriptionState</span></code></a>.</p>
</dd></dl>

</div></blockquote>
</li>
<li><p class="first">Other attributes:</p>
<blockquote>
<div><dl class="attribute">
<dt id="pyuaf.client.KeepAliveNotification.clientHandles">
<code class="descname">clientHandles</code><a class="headerlink" href="#pyuaf.client.KeepAliveNotification.clientHandles" title="Permalink to this definition">¶</a></dt>
<dd><p>The client handles assigned to the subscription that got a keep alive message,
as a <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.UInt32Vector" title="pyuaf.util.UInt32Vector"><code class="xref py py-class docutils literal"><span class="pre">UInt32Vector</span></code></a>.</p>
<p>So if you receive a KeepAliveNotification, you know that the monitored items identified
by these handles are OK.</p>
</dd></dl>

</div></blockquote>
</li>
</ul>
</dd></dl>

</div>
<div class="section" id="class-sessioninformation">
<h2><em>class</em> SessionInformation<a class="headerlink" href="#class-sessioninformation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyuaf.client.SessionInformation">
<em class="property">class </em><code class="descclassname">pyuaf.client.</code><code class="descname">SessionInformation</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.SessionInformation" title="Permalink to this definition">¶</a></dt>
<dd><p>A SessionInformation object contains information about a session such as the state of the
session, the server URI of the server to which it is connected, etc.</p>
<ul>
<li><p class="first">Methods:</p>
<blockquote>
<div><dl class="method">
<dt id="pyuaf.client.SessionInformation.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.SessionInformation.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a new SessionInformation object.</p>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.SessionInformation.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.SessionInformation.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a string representation.</p>
</dd></dl>

</div></blockquote>
</li>
<li><p class="first">Attributes:</p>
<blockquote>
<div><dl class="attribute">
<dt id="pyuaf.client.SessionInformation.clientConnectionId">
<code class="descname">clientConnectionId</code><a class="headerlink" href="#pyuaf.client.SessionInformation.clientConnectionId" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the session, as a <code class="docutils literal"><span class="pre">long</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.SessionInformation.sessionState">
<code class="descname">sessionState</code><a class="headerlink" href="#pyuaf.client.SessionInformation.sessionState" title="Permalink to this definition">¶</a></dt>
<dd><p>An <code class="docutils literal"><span class="pre">int</span></code> representing the state of the session
(e.g. <a class="reference internal" href="api_pyuaf_client_sessionstates.html#pyuaf.client.sessionstates.Connected" title="pyuaf.client.sessionstates.Connected"><code class="xref py py-attr docutils literal"><span class="pre">Connected</span></code></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.SessionInformation.serverState">
<code class="descname">serverState</code><a class="headerlink" href="#pyuaf.client.SessionInformation.serverState" title="Permalink to this definition">¶</a></dt>
<dd><p>An <code class="docutils literal"><span class="pre">int</span></code> representing the state of the server
(e.g. <a class="reference internal" href="api_pyuaf_util_serverstates.html#pyuaf.util.serverstates.Running" title="pyuaf.util.serverstates.Running"><code class="xref py py-attr docutils literal"><span class="pre">Running</span></code></a>).</p>
<p>The possible states are defined in the <a class="reference internal" href="api_pyuaf_util_serverstates.html#module-pyuaf.util.serverstates" title="pyuaf.util.serverstates"><code class="xref py py-mod docutils literal"><span class="pre">pyuaf.util.serverstates</span></code></a> module.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.SessionInformation.serverUri">
<code class="descname">serverUri</code><a class="headerlink" href="#pyuaf.client.SessionInformation.serverUri" title="Permalink to this definition">¶</a></dt>
<dd><p>The URI of the server to which the session should be connected, as a <code class="docutils literal"><span class="pre">str</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.SessionInformation.lastConnectionAttemptStep">
<code class="descname">lastConnectionAttemptStep</code><a class="headerlink" href="#pyuaf.client.SessionInformation.lastConnectionAttemptStep" title="Permalink to this definition">¶</a></dt>
<dd><p>The step of the connection process (corresponding to the
<a class="reference internal" href="#pyuaf.client.SessionInformation.lastConnectionAttemptStatus" title="pyuaf.client.SessionInformation.lastConnectionAttemptStatus"><code class="xref py py-attr docutils literal"><span class="pre">lastConnectionAttemptStatus</span></code></a>), as an <code class="docutils literal"><span class="pre">int</span></code>.</p>
<p>The possible steps are defined in the <a class="reference internal" href="api_pyuaf_client_connectionsteps.html#module-pyuaf.client.connectionsteps" title="pyuaf.client.connectionsteps"><code class="xref py py-mod docutils literal"><span class="pre">pyuaf.client.connectionsteps</span></code></a> module.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.SessionInformation.lastConnectionAttemptStatus">
<code class="descname">lastConnectionAttemptStatus</code><a class="headerlink" href="#pyuaf.client.SessionInformation.lastConnectionAttemptStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>The status of the last connection attempt, as a <a class="reference internal" href="api_pyuaf_util.html#pyuaf.util.Status" title="pyuaf.util.Status"><code class="xref py py-class docutils literal"><span class="pre">Status</span></code></a> instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.SessionInformation.sessionSettings">
<code class="descname">sessionSettings</code><a class="headerlink" href="#pyuaf.client.SessionInformation.sessionSettings" title="Permalink to this definition">¶</a></dt>
<dd><p>The session settings of the session (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SessionSettings" title="pyuaf.client.settings.SessionSettings"><code class="xref py py-class docutils literal"><span class="pre">SessionSettings</span></code></a>).</p>
</dd></dl>

</div></blockquote>
</li>
</ul>
</dd></dl>

</div>
<div class="section" id="class-subscriptioninformation">
<h2><em>class</em> SubscriptionInformation<a class="headerlink" href="#class-subscriptioninformation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyuaf.client.SubscriptionInformation">
<em class="property">class </em><code class="descclassname">pyuaf.client.</code><code class="descname">SubscriptionInformation</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.SubscriptionInformation" title="Permalink to this definition">¶</a></dt>
<dd><p>A SubscriptionInformation object contains information about a subscription such as the
state of the subscription, the handle, etc.</p>
<ul>
<li><p class="first">Methods:</p>
<blockquote>
<div><dl class="method">
<dt id="pyuaf.client.SubscriptionInformation.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.SubscriptionInformation.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a new SubscriptionInformation object.</p>
</dd></dl>

<dl class="method">
<dt id="pyuaf.client.SubscriptionInformation.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyuaf.client.SubscriptionInformation.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a string representation.</p>
</dd></dl>

</div></blockquote>
</li>
<li><p class="first">Attributes:</p>
<blockquote>
<div><dl class="attribute">
<dt id="pyuaf.client.SubscriptionInformation.clientConnectionId">
<code class="descname">clientConnectionId</code><a class="headerlink" href="#pyuaf.client.SubscriptionInformation.clientConnectionId" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the session that hosts the subscription, as a <code class="docutils literal"><span class="pre">long</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.SubscriptionInformation.clientSubscriptionHandle">
<code class="descname">clientSubscriptionHandle</code><a class="headerlink" href="#pyuaf.client.SubscriptionInformation.clientSubscriptionHandle" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle of the subscription, as a <code class="docutils literal"><span class="pre">long</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.SubscriptionInformation.subscriptionState">
<code class="descname">subscriptionState</code><a class="headerlink" href="#pyuaf.client.SubscriptionInformation.subscriptionState" title="Permalink to this definition">¶</a></dt>
<dd><p>An <code class="docutils literal"><span class="pre">int</span></code> representing the state of the subscription
(e.g. <a class="reference internal" href="api_pyuaf_client_subscriptionstates.html#pyuaf.client.subscriptionstates.Created" title="pyuaf.client.subscriptionstates.Created"><code class="xref py py-attr docutils literal"><span class="pre">Created</span></code></a>).</p>
<p>The possible states are defined in the <a class="reference internal" href="api_pyuaf_client_subscriptionstates.html#module-pyuaf.client.subscriptionstates" title="pyuaf.client.subscriptionstates"><code class="xref py py-mod docutils literal"><span class="pre">pyuaf.client.subscriptionstates</span></code></a> module.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyuaf.client.SubscriptionInformation.subscriptionSettings">
<code class="descname">subscriptionSettings</code><a class="headerlink" href="#pyuaf.client.SubscriptionInformation.subscriptionSettings" title="Permalink to this definition">¶</a></dt>
<dd><p>The subscription settings of the subscription (type: <a class="reference internal" href="api_pyuaf_client_settings.html#pyuaf.client.settings.SubscriptionSettings" title="pyuaf.client.settings.SubscriptionSettings"><code class="xref py py-class docutils literal"><span class="pre">SubscriptionSettings</span></code></a>).</p>
</dd></dl>

</div></blockquote>
</li>
</ul>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/uaf_logo_200x67_transparent.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">pyuaf.client</span></code></a><ul>
<li><a class="reference internal" href="#class-client"><em>class</em> Client</a></li>
<li><a class="reference internal" href="#class-monitorediteminformation"><em>class</em> MonitoredItemInformation</a></li>
<li><a class="reference internal" href="#class-monitoreditemnotification"><em>class</em> MonitoredItemNotification</a></li>
<li><a class="reference internal" href="#class-datachangenotification"><em>class</em> DataChangeNotification</a></li>
<li><a class="reference internal" href="#class-eventnotification"><em>class</em> EventNotification</a></li>
<li><a class="reference internal" href="#class-keepalivenotification"><em>class</em> KeepAliveNotification</a></li>
<li><a class="reference internal" href="#class-sessioninformation"><em>class</em> SessionInformation</a></li>
<li><a class="reference internal" href="#class-subscriptioninformation"><em>class</em> SubscriptionInformation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="api_pyuaf.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">pyuaf</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="api_pyuaf_client_connectionsteps.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">pyuaf.client.connectionsteps</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/api_pyuaf_client.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api_pyuaf_client_connectionsteps.html" title="pyuaf.client.connectionsteps"
             >next</a> |</li>
        <li class="right" >
          <a href="api_pyuaf.html" title="pyuaf"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyUAF 2.3.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2013, Wim Pessemier (Institute for Astronomy, KU Leuven) - http://github.com/uaf.
    </div>
  </body>
</html>